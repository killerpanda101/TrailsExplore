{"ast":null,"code":"import { animated as t, to as n, useTransition as e, useSpring as r } from \"@react-spring/web\";\nimport { useTheme as i, radiansToDegrees as a, positionFromAngle as o, degreesToRadians as u, midAngle as l, useMotionConfig as s, usePropertyAccessor as d, textPropsByEngine as f, getDistance as c, getAngle as g } from \"@nivo/core\";\nimport { jsx as p, jsxs as h } from \"react/jsx-runtime\";\nimport { useMemo as v, createElement as A, useCallback as x } from \"react\";\nimport { useInheritedColor as R } from \"@nivo/colors\";\nimport { line as m, arc as y } from \"d3-shape\";\nfunction M() {\n  return M = Object.assign ? Object.assign.bind() : function (t) {\n    for (var n = 1; n < arguments.length; n++) {\n      var e = arguments[n];\n      for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);\n    }\n    return t;\n  }, M.apply(this, arguments);\n}\nvar k = {\n    pointerEvents: \"none\"\n  },\n  b = function (n) {\n    var e = n.label,\n      r = n.style,\n      a = i();\n    return p(t.g, {\n      transform: r.transform,\n      opacity: r.progress,\n      style: k,\n      children: p(t.text, {\n        textAnchor: \"middle\",\n        dominantBaseline: \"central\",\n        style: M({}, a.labels.text, {\n          fill: r.textColor\n        }),\n        children: e\n      })\n    });\n  },\n  C = function (t) {\n    var n = t % (2 * Math.PI);\n    return n < 0 && (n += 2 * Math.PI), n;\n  },\n  L = function (t, n) {\n    return t.filter(function (t) {\n      return Math.abs(a(t.arc.endAngle - t.arc.startAngle)) >= n;\n    });\n  },\n  O = function (t, n, e, r, i) {\n    return [\"A\", t, t, 0, n, e, r, i].join(\" \");\n  },\n  P = [\"startAngle\", \"middleAngle\", \"endAngle\", \"innerRadius\", \"centerRadius\", \"outerRadius\", \"pushIn\", \"pushOut\"],\n  E = {\n    startAngle: {\n      enter: function (t) {\n        return M({}, t, {\n          endAngle: t.startAngle\n        });\n      },\n      update: function (t) {\n        return t;\n      },\n      leave: function (t) {\n        return M({}, t, {\n          startAngle: t.endAngle\n        });\n      }\n    },\n    middleAngle: {\n      enter: function (t) {\n        var n = t.startAngle + (t.endAngle - t.startAngle) / 2;\n        return M({}, t, {\n          startAngle: n,\n          endAngle: n\n        });\n      },\n      update: function (t) {\n        return t;\n      },\n      leave: function (t) {\n        var n = t.startAngle + (t.endAngle - t.startAngle) / 2;\n        return M({}, t, {\n          startAngle: n,\n          endAngle: n\n        });\n      }\n    },\n    endAngle: {\n      enter: function (t) {\n        return M({}, t, {\n          startAngle: t.endAngle\n        });\n      },\n      update: function (t) {\n        return t;\n      },\n      leave: function (t) {\n        return M({}, t, {\n          endAngle: t.startAngle\n        });\n      }\n    },\n    innerRadius: {\n      enter: function (t) {\n        return M({}, t, {\n          outerRadius: t.innerRadius\n        });\n      },\n      update: function (t) {\n        return t;\n      },\n      leave: function (t) {\n        return M({}, t, {\n          innerRadius: t.outerRadius\n        });\n      }\n    },\n    centerRadius: {\n      enter: function (t) {\n        var n = t.innerRadius + (t.outerRadius - t.innerRadius) / 2;\n        return M({}, t, {\n          innerRadius: n,\n          outerRadius: n\n        });\n      },\n      update: function (t) {\n        return t;\n      },\n      leave: function (t) {\n        var n = t.innerRadius + (t.outerRadius - t.innerRadius) / 2;\n        return M({}, t, {\n          innerRadius: n,\n          outerRadius: n\n        });\n      }\n    },\n    outerRadius: {\n      enter: function (t) {\n        return M({}, t, {\n          innerRadius: t.outerRadius\n        });\n      },\n      update: function (t) {\n        return t;\n      },\n      leave: function (t) {\n        return M({}, t, {\n          outerRadius: t.innerRadius\n        });\n      }\n    },\n    pushIn: {\n      enter: function (t) {\n        return M({}, t, {\n          innerRadius: t.innerRadius - t.outerRadius + t.innerRadius,\n          outerRadius: t.innerRadius\n        });\n      },\n      update: function (t) {\n        return t;\n      },\n      leave: function (t) {\n        return M({}, t, {\n          innerRadius: t.outerRadius,\n          outerRadius: t.outerRadius + t.outerRadius - t.innerRadius\n        });\n      }\n    },\n    pushOut: {\n      enter: function (t) {\n        return M({}, t, {\n          innerRadius: t.outerRadius,\n          outerRadius: t.outerRadius + t.outerRadius - t.innerRadius\n        });\n      },\n      update: function (t) {\n        return t;\n      },\n      leave: function (t) {\n        return M({}, t, {\n          innerRadius: t.innerRadius - t.outerRadius + t.innerRadius,\n          outerRadius: t.innerRadius\n        });\n      }\n    }\n  },\n  I = function (t, n) {\n    return v(function () {\n      var e = E[t];\n      return {\n        enter: function (t) {\n          return M({\n            progress: 0\n          }, e.enter(t.arc), n ? n.enter(t) : {});\n        },\n        update: function (t) {\n          return M({\n            progress: 1\n          }, e.update(t.arc), n ? n.update(t) : {});\n        },\n        leave: function (t) {\n          return M({\n            progress: 0\n          }, e.leave(t.arc), n ? n.leave(t) : {});\n        }\n      };\n    }, [t, n]);\n  },\n  T = function (t, n) {\n    var e = l(t) - Math.PI / 2,\n      r = t.innerRadius + (t.outerRadius - t.innerRadius) * n;\n    return o(e, r);\n  },\n  j = function (t) {\n    return function (e, r, i, a) {\n      return n([e, r, i, a], function (n, e, r, i) {\n        var a = T({\n          startAngle: n,\n          endAngle: e,\n          innerRadius: r,\n          outerRadius: i\n        }, t);\n        return \"translate(\" + a.x + \",\" + a.y + \")\";\n      });\n    };\n  },\n  W = function (t, n, r, i) {\n    void 0 === n && (n = .5), void 0 === r && (r = \"innerRadius\");\n    var a = s(),\n      o = a.animate,\n      u = a.config,\n      l = I(r, i);\n    return {\n      transition: e(t, {\n        keys: function (t) {\n          return t.id;\n        },\n        initial: l.update,\n        from: l.enter,\n        enter: l.update,\n        update: l.update,\n        leave: l.leave,\n        config: u,\n        immediate: !o\n      }),\n      interpolate: j(n)\n    };\n  },\n  S = function (t) {\n    var n = t.data,\n      e = t.offset,\n      r = void 0 === e ? .5 : e,\n      i = t.skipAngle,\n      a = void 0 === i ? 0 : i,\n      o = t.computeExtraProps,\n      u = void 0 === o ? function () {\n        return {};\n      } : o;\n    return v(function () {\n      return L(n, a).map(function (t) {\n        var n = T(t.arc, r);\n        return M({}, u(t), {\n          x: n.x,\n          y: n.y,\n          data: t\n        });\n      });\n    }, [n, r, a, u]);\n  },\n  B = function (t) {\n    var n = t.center,\n      e = t.data,\n      r = t.transitionMode,\n      o = t.label,\n      u = t.radiusOffset,\n      l = t.skipAngle,\n      s = t.textColor,\n      f = t.component,\n      c = void 0 === f ? b : f,\n      g = d(o),\n      h = i(),\n      x = R(s, h),\n      m = v(function () {\n        return e.filter(function (t) {\n          return Math.abs(a(t.arc.endAngle - t.arc.startAngle)) >= l;\n        });\n      }, [e, l]),\n      y = W(m, u, r),\n      k = y.transition,\n      C = y.interpolate,\n      L = c;\n    return p(\"g\", {\n      transform: \"translate(\" + n[0] + \",\" + n[1] + \")\",\n      children: k(function (t, n) {\n        return A(L, {\n          key: n.id,\n          datum: n,\n          label: g(n),\n          style: M({}, t, {\n            transform: C(t.startAngle, t.endAngle, t.innerRadius, t.outerRadius),\n            textColor: x(n)\n          })\n        });\n      })\n    });\n  },\n  w = function (t, n, e) {\n    t.textAlign = \"center\", t.textBaseline = \"middle\", t.font = e.labels.text.fontSize + \"px \" + e.labels.text.fontFamily, n.forEach(function (n) {\n      t.fillStyle = n.textColor, t.fillText(\"\" + n.label, n.x, n.y);\n    });\n  },\n  z = function (t) {\n    var n = t.data,\n      e = t.offset,\n      r = t.skipAngle,\n      a = t.label,\n      o = t.textColor,\n      u = d(a),\n      l = i(),\n      s = R(o, l),\n      f = x(function (t) {\n        return {\n          label: u(t),\n          textColor: s(t)\n        };\n      }, [u, s]);\n    return S({\n      data: n,\n      offset: e,\n      skipAngle: r,\n      computeExtraProps: f\n    });\n  },\n  F = b,\n  G = function (n) {\n    var e = n.label,\n      r = n.style,\n      a = i();\n    return h(t.g, {\n      opacity: r.opacity,\n      children: [p(t.path, {\n        fill: \"none\",\n        stroke: r.linkColor,\n        strokeWidth: r.thickness,\n        d: r.path\n      }), p(t.text, {\n        transform: r.textPosition,\n        textAnchor: r.textAnchor,\n        dominantBaseline: \"central\",\n        style: M({}, a.labels.text, {\n          fill: r.textColor\n        }),\n        children: e\n      })]\n    });\n  },\n  q = function (t) {\n    var n = C(t.startAngle + (t.endAngle - t.startAngle) / 2 - Math.PI / 2);\n    return n < Math.PI / 2 || n > 1.5 * Math.PI ? \"start\" : \"end\";\n  },\n  D = function (t, n, e, r) {\n    var i,\n      a,\n      u = C(t.startAngle + (t.endAngle - t.startAngle) / 2 - Math.PI / 2),\n      l = o(u, t.outerRadius + n),\n      s = o(u, t.outerRadius + n + e);\n    return u < Math.PI / 2 || u > 1.5 * Math.PI ? (i = \"after\", a = {\n      x: s.x + r,\n      y: s.y\n    }) : (i = \"before\", a = {\n      x: s.x - r,\n      y: s.y\n    }), {\n      side: i,\n      points: [l, s, a]\n    };\n  },\n  H = m().x(function (t) {\n    return t.x;\n  }).y(function (t) {\n    return t.y;\n  }),\n  J = function (t, e, r, i, a, o, u) {\n    return n([t, e, r, i, a, o, u], function (t, n, e, r, i, a, o) {\n      var u = D({\n        startAngle: t,\n        endAngle: n,\n        innerRadius: e,\n        outerRadius: r\n      }, i, a, o).points;\n      return H(u);\n    });\n  },\n  K = function (t, e, r, i) {\n    return n([t, e, r, i], function (t, n, e, r) {\n      return q({\n        startAngle: t,\n        endAngle: n,\n        innerRadius: e,\n        outerRadius: r\n      });\n    });\n  },\n  N = function (t, e, r, i, a, o, u, l) {\n    return n([t, e, r, i, a, o, u, l], function (t, n, e, r, i, a, o, u) {\n      var l = D({\n          startAngle: t,\n          endAngle: n,\n          innerRadius: e,\n          outerRadius: r\n        }, i, a, o),\n        s = l.points,\n        d = l.side,\n        f = s[2];\n      return \"before\" === d ? f.x -= u : f.x += u, \"translate(\" + f.x + \",\" + f.y + \")\";\n    });\n  },\n  Q = function (t) {\n    var n = t.data,\n      r = t.offset,\n      a = void 0 === r ? 0 : r,\n      o = t.diagonalLength,\n      u = t.straightLength,\n      l = t.skipAngle,\n      d = void 0 === l ? 0 : l,\n      f = t.textOffset,\n      c = t.linkColor,\n      g = t.textColor,\n      p = s(),\n      h = p.animate,\n      A = p.config,\n      x = i(),\n      m = R(c, x),\n      y = R(g, x),\n      M = function (t, n) {\n        return v(function () {\n          return L(t, n);\n        }, [t, n]);\n      }(n, d),\n      k = function (t) {\n        var n = t.offset,\n          e = t.diagonalLength,\n          r = t.straightLength,\n          i = t.textOffset,\n          a = t.getLinkColor,\n          o = t.getTextColor;\n        return v(function () {\n          return {\n            enter: function (t) {\n              return {\n                startAngle: t.arc.startAngle,\n                endAngle: t.arc.endAngle,\n                innerRadius: t.arc.innerRadius,\n                outerRadius: t.arc.outerRadius,\n                offset: n,\n                diagonalLength: 0,\n                straightLength: 0,\n                textOffset: i,\n                linkColor: a(t),\n                textColor: o(t),\n                opacity: 0\n              };\n            },\n            update: function (t) {\n              return {\n                startAngle: t.arc.startAngle,\n                endAngle: t.arc.endAngle,\n                innerRadius: t.arc.innerRadius,\n                outerRadius: t.arc.outerRadius,\n                offset: n,\n                diagonalLength: e,\n                straightLength: r,\n                textOffset: i,\n                linkColor: a(t),\n                textColor: o(t),\n                opacity: 1\n              };\n            },\n            leave: function (t) {\n              return {\n                startAngle: t.arc.startAngle,\n                endAngle: t.arc.endAngle,\n                innerRadius: t.arc.innerRadius,\n                outerRadius: t.arc.outerRadius,\n                offset: n,\n                diagonalLength: 0,\n                straightLength: 0,\n                textOffset: i,\n                linkColor: a(t),\n                textColor: o(t),\n                opacity: 0\n              };\n            }\n          };\n        }, [e, r, i, a, o, n]);\n      }({\n        offset: a,\n        diagonalLength: o,\n        straightLength: u,\n        textOffset: f,\n        getLinkColor: m,\n        getTextColor: y\n      });\n    return {\n      transition: e(M, {\n        keys: function (t) {\n          return t.id;\n        },\n        initial: k.update,\n        from: k.enter,\n        enter: k.update,\n        update: k.update,\n        leave: k.leave,\n        config: A,\n        immediate: !h\n      }),\n      interpolateLink: J,\n      interpolateTextAnchor: K,\n      interpolateTextPosition: N\n    };\n  },\n  U = function (t) {\n    var n = t.center,\n      e = t.data,\n      r = t.label,\n      i = t.skipAngle,\n      a = t.offset,\n      o = t.diagonalLength,\n      u = t.straightLength,\n      l = t.strokeWidth,\n      s = t.textOffset,\n      f = t.textColor,\n      c = t.linkColor,\n      g = t.component,\n      h = void 0 === g ? G : g,\n      v = d(r),\n      x = Q({\n        data: e,\n        skipAngle: i,\n        offset: a,\n        diagonalLength: o,\n        straightLength: u,\n        textOffset: s,\n        linkColor: c,\n        textColor: f\n      }),\n      R = x.transition,\n      m = x.interpolateLink,\n      y = x.interpolateTextAnchor,\n      k = x.interpolateTextPosition,\n      b = h;\n    return p(\"g\", {\n      transform: \"translate(\" + n[0] + \",\" + n[1] + \")\",\n      children: R(function (t, n) {\n        return A(b, {\n          key: n.id,\n          datum: n,\n          label: v(n),\n          style: M({}, t, {\n            thickness: l,\n            path: m(t.startAngle, t.endAngle, t.innerRadius, t.outerRadius, t.offset, t.diagonalLength, t.straightLength),\n            textAnchor: y(t.startAngle, t.endAngle, t.innerRadius, t.outerRadius),\n            textPosition: k(t.startAngle, t.endAngle, t.innerRadius, t.outerRadius, t.offset, t.diagonalLength, t.straightLength, t.textOffset)\n          })\n        });\n      })\n    });\n  },\n  V = function (t, n, e, r) {\n    t.textBaseline = \"middle\", t.font = e.labels.text.fontSize + \"px \" + e.labels.text.fontFamily, n.forEach(function (n) {\n      t.fillStyle = n.textColor, t.textAlign = f.canvas.align[n.textAnchor], t.fillText(\"\" + n.label, n.x, n.y), t.beginPath(), t.strokeStyle = n.linkColor, t.lineWidth = r, n.points.forEach(function (n, e) {\n        0 === e ? t.moveTo(n.x, n.y) : t.lineTo(n.x, n.y);\n      }), t.stroke();\n    });\n  },\n  X = function (t) {\n    var n = t.data,\n      e = t.skipAngle,\n      r = void 0 === e ? 0 : e,\n      i = t.offset,\n      o = void 0 === i ? .5 : i,\n      u = t.diagonalLength,\n      l = t.straightLength,\n      s = t.computeExtraProps,\n      d = void 0 === s ? function () {\n        return {};\n      } : s,\n      f = v(function () {\n        return n.filter(function (t) {\n          return Math.abs(a(t.arc.endAngle - t.arc.startAngle)) >= r;\n        }).map(function (t) {\n          return M({}, D(t.arc, o, u, l), {\n            data: t\n          });\n        });\n      }, [n, r, o, u, l]);\n    return v(function () {\n      return f.map(function (t) {\n        return M({}, d(t), t);\n      });\n    }, [f, d]);\n  },\n  Y = function (t) {\n    var n = t.data,\n      e = t.skipAngle,\n      r = t.offset,\n      a = t.diagonalLength,\n      o = t.straightLength,\n      u = t.textOffset,\n      l = void 0 === u ? 0 : u,\n      s = t.label,\n      f = t.linkColor,\n      c = t.textColor,\n      g = d(s),\n      p = i(),\n      h = R(f, p),\n      v = R(c, p),\n      A = x(function (t) {\n        var n,\n          e = {\n            x: t.points[2].x,\n            y: t.points[2].y\n          };\n        return \"before\" === t.side ? (e.x -= l, n = \"end\") : (e.x += l, n = \"start\"), M({}, e, {\n          label: g(t.data),\n          linkColor: h(t.data),\n          textAnchor: n,\n          textColor: v(t.data)\n        });\n      }, [g, h, v, l]);\n    return X({\n      data: n,\n      skipAngle: e,\n      offset: r,\n      diagonalLength: a,\n      straightLength: o,\n      computeExtraProps: A\n    });\n  },\n  Z = G,\n  $ = [\"animated\"],\n  _ = function (e) {\n    var r = e.animated,\n      i = function (t, n) {\n        if (null == t) return {};\n        var e,\n          r,\n          i = {},\n          a = Object.keys(t);\n        for (r = 0; r < a.length; r++) e = a[r], n.indexOf(e) >= 0 || (i[e] = t[e]);\n        return i;\n      }(e, $);\n    return p(t.path, M({\n      d: n([r.radius, r.startAngle, r.endAngle], function (t, n, e) {\n        return function (t, n, e) {\n          var r = Math.min(n, e),\n            i = Math.max(n, e),\n            a = o(u(i), t),\n            l = o(u(r), t);\n          if (i - r >= 360) {\n            var s = o(u(r + 180), t);\n            return [\"M \" + a.x + \" \" + a.y, O(t, 1, 1, s.x, s.y), \"M \" + a.x + \" \" + a.y, O(t, 1, 0, s.x, s.y)].join(\" \");\n          }\n          var d = i - r <= 180 ? 0 : 1;\n          return [\"M \" + a.x + \" \" + a.y, O(t, d, 0, l.x, l.y)].join(\" \");\n        }(t, n, e);\n      })\n    }, i));\n  },\n  tt = function (n) {\n    var e = n.datum,\n      r = n.style,\n      i = n.onClick,\n      a = n.onMouseEnter,\n      o = n.onMouseMove,\n      u = n.onMouseLeave,\n      l = x(function (t) {\n        return null == i ? void 0 : i(e, t);\n      }, [i, e]),\n      s = x(function (t) {\n        return null == a ? void 0 : a(e, t);\n      }, [a, e]),\n      d = x(function (t) {\n        return null == o ? void 0 : o(e, t);\n      }, [o, e]),\n      f = x(function (t) {\n        return null == u ? void 0 : u(e, t);\n      }, [u, e]);\n    return p(t.path, {\n      d: r.path,\n      opacity: r.opacity,\n      fill: e.fill || r.color,\n      stroke: r.borderColor,\n      strokeWidth: r.borderWidth,\n      onClick: i ? l : void 0,\n      onMouseEnter: a ? s : void 0,\n      onMouseMove: o ? d : void 0,\n      onMouseLeave: u ? f : void 0\n    });\n  },\n  nt = function (t, e, r, i, a) {\n    return n([t, e, r, i], function (t, n, e, r) {\n      return a({\n        startAngle: t,\n        endAngle: n,\n        innerRadius: Math.max(0, e),\n        outerRadius: Math.max(0, r)\n      });\n    });\n  },\n  et = function (t, n, r) {\n    void 0 === n && (n = \"innerRadius\");\n    var i = s(),\n      a = i.animate,\n      o = i.config,\n      u = I(n, r);\n    return {\n      transition: e(t, {\n        keys: function (t) {\n          return t.id;\n        },\n        initial: u.update,\n        from: u.enter,\n        enter: u.update,\n        update: u.update,\n        leave: u.leave,\n        config: o,\n        immediate: !a\n      }),\n      interpolate: nt\n    };\n  },\n  rt = function (t) {\n    var n = t.center,\n      e = t.data,\n      r = t.arcGenerator,\n      a = t.borderWidth,\n      o = t.borderColor,\n      u = t.onClick,\n      l = t.onMouseEnter,\n      s = t.onMouseMove,\n      d = t.onMouseLeave,\n      f = t.transitionMode,\n      c = t.component,\n      g = void 0 === c ? tt : c,\n      h = i(),\n      v = R(o, h),\n      x = et(e, f, {\n        enter: function (t) {\n          return {\n            opacity: 0,\n            color: t.color,\n            borderColor: v(t)\n          };\n        },\n        update: function (t) {\n          return {\n            opacity: 1,\n            color: t.color,\n            borderColor: v(t)\n          };\n        },\n        leave: function (t) {\n          return {\n            opacity: 0,\n            color: t.color,\n            borderColor: v(t)\n          };\n        }\n      }),\n      m = x.transition,\n      y = x.interpolate,\n      k = g;\n    return p(\"g\", {\n      transform: \"translate(\" + n[0] + \",\" + n[1] + \")\",\n      children: m(function (t, n) {\n        return A(k, {\n          key: n.id,\n          datum: n,\n          style: M({}, t, {\n            borderWidth: a,\n            path: y(t.startAngle, t.endAngle, t.innerRadius, t.outerRadius, r)\n          }),\n          onClick: u,\n          onMouseEnter: l,\n          onMouseMove: s,\n          onMouseLeave: d\n        });\n      })\n    });\n  },\n  it = function (t, n, e, r, i, a) {\n    void 0 === a && (a = !0);\n    var l = [],\n      s = o(u(r), e);\n    l.push([s.x, s.y]);\n    var d = o(u(i), e);\n    l.push([d.x, d.y]);\n    for (var f = Math.round(Math.min(r, i)); f <= Math.round(Math.max(r, i)); f++) if (f % 90 == 0) {\n      var c = o(u(f), e);\n      l.push([c.x, c.y]);\n    }\n    l = l.map(function (e) {\n      var r = e[0],\n        i = e[1];\n      return [t + r, n + i];\n    }), a && l.push([t, n]);\n    var g = l.map(function (t) {\n        return t[0];\n      }),\n      p = l.map(function (t) {\n        return t[1];\n      }),\n      h = Math.min.apply(Math, g),\n      v = Math.max.apply(Math, g),\n      A = Math.min.apply(Math, p);\n    return {\n      points: l,\n      x: h,\n      y: A,\n      width: v - h,\n      height: Math.max.apply(Math, p) - A\n    };\n  },\n  at = function (t, n, e, r, i, a) {\n    var o = c(i, a, t, n);\n    return o < e && o > r;\n  },\n  ot = function (t, n, e, r, i, a, o) {\n    if (at(t, n, e, r, a, o)) {\n      var u = g(a, o, t, n);\n      return i.find(function (t) {\n        var n = t.startAngle,\n          e = t.endAngle;\n        return u >= n && u < e;\n      });\n    }\n  },\n  ut = function (t, n) {\n    var e = s(),\n      i = e.animate,\n      a = e.config,\n      o = r({\n        startAngle: t.arc.startAngle,\n        endAngle: t.arc.endAngle,\n        innerRadius: t.arc.innerRadius,\n        outerRadius: t.arc.outerRadius,\n        config: a,\n        immediate: !i\n      });\n    return M({}, o, {\n      path: nt(o.startAngle, o.endAngle, o.innerRadius, o.outerRadius, n)\n    });\n  },\n  lt = function (t) {\n    var n = void 0 === t ? {} : t,\n      e = n.cornerRadius,\n      r = void 0 === e ? 0 : e,\n      i = n.padAngle,\n      a = void 0 === i ? 0 : i;\n    return v(function () {\n      return y().innerRadius(function (t) {\n        return t.innerRadius;\n      }).outerRadius(function (t) {\n        return t.outerRadius;\n      }).cornerRadius(r).padAngle(a);\n    }, [r, a]);\n  };\nexport { F as ArcLabelComponent, B as ArcLabelsLayer, _ as ArcLine, Z as ArcLinkLabelComponent, U as ArcLinkLabelsLayer, tt as ArcShape, rt as ArcsLayer, E as arcTransitionModeById, P as arcTransitionModes, it as computeArcBoundingBox, T as computeArcCenter, D as computeArcLink, q as computeArcLinkTextAnchor, w as drawCanvasArcLabels, V as drawCanvasArcLinkLabels, ot as findArcUnderCursor, nt as interpolateArc, j as interpolateArcCenter, at as isCursorInRing, ut as useAnimatedArc, S as useArcCenters, W as useArcCentersTransition, lt as useArcGenerator, z as useArcLabels, Y as useArcLinkLabels, Q as useArcLinkLabelsTransition, X as useArcLinks, I as useArcTransitionMode, et as useArcsTransition };","map":{"version":3,"mappings":"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","names":["staticStyle","pointerEvents","ArcLabel","_ref","label","style","theme","useTheme","_jsx","animated","g","transform","opacity","progress","children","text","textAnchor","dominantBaseline","_extends","labels","fill","textColor","getNormalizedAngle","angle","normalizedAngle","Math","PI","filterDataBySkipAngle","data","skipAngle","filter","abs","radiansToDegrees","datum","arc","endAngle","startAngle","svgEllipticalArcCommand","radius","largeArcFlag","sweepFlag","x","y","join","arcTransitionModes","arcTransitionModeById","enter","update","leave","middleAngle","innerRadius","outerRadius","centerRadius","pushIn","pushOut","useArcTransitionMode","mode","extraTransition","useMemo","transitionMode","computeArcCenter","offset","midAngle","positionFromAngle","interpolateArcCenter","startAngleValue","endAngleValue","innerRadiusValue","outerRadiusValue","to","centroid","useArcCentersTransition","extra","useMotionConfig","animate","_useMotionConfig","springConfig","config","phases","transition","useTransition","keys","id","initial","from","immediate","interpolate","useArcCenters","_ref$offset","_ref$skipAngle","_ref$computeExtraProp","computeExtraProps","map","position","ArcLabelsLayer","center","labelAccessor","radiusOffset","_ref$component","component","getLabel","usePropertyAccessor","getTextColor","useInheritedColor","filteredData","_useArcCentersTransit","Label","transitionProps","createElement","key","drawCanvasArcLabels","ctx","textAlign","textBaseline","font","fontSize","fontFamily","forEach","fillStyle","fillText","useArcLabels","useCallback","ArcLabelComponent","ArcLinkLabel","_jsxs","path","stroke","linkColor","strokeWidth","thickness","d","textPosition","computeArcLinkTextAnchor","centerAngle","computeArcLink","diagonalLength","straightLength","side","point2","point0","point1","points","lineGenerator","line","interpolateLink","offsetValue","diagonalLengthValue","straightLengthValue","diagonalLengthAnimated","straightLengthAnimated","interpolateTextAnchor","interpolateTextPosition","textOffsetValue","textOffset","_computeArcLink2","useArcLinkLabelsTransition","_ref2","_ref2$offset","_ref2$skipAngle","getLinkColor","useFilteredDataBySkipAngle","transitionPhases","useTransitionPhases","ArcLinkLabelsLayer","_useArcLinkLabelsTran","drawCanvasArcLinkLabels","textPropsByEngine","canvas","align","beginPath","strokeStyle","lineWidth","point","index","moveTo","lineTo","useArcLinks","links","link","useArcLinkLabels","_ref$textOffset","ArcLinkLabelComponent","ArcLine","animatedProps","rest","_objectWithoutPropertiesLoose","start","end","originalStartAngle","originalEndAngle","min","max","degreesToRadians","mid","generateSvgArc","ArcShape","onClick","onMouseEnter","onMouseMove","onMouseLeave","handleClick","event","handleMouseEnter","handleMouseMove","handleMouseLeave","color","borderColor","borderWidth","undefined","interpolateArc","arcGenerator","useArcsTransition","ArcsLayer","getBorderColor","_useArcsTransition","Arc","computeArcBoundingBox","centerX","centerY","includeCenter","p0","push","p1","round","p","xs","ys","x0","apply","x1","y0","width","height","isCursorInRing","cursorX","cursorY","distance","getDistance","findArcUnderCursor","arcs","cursorAngle","getAngle","find","useAnimatedArc","datumWithArc","animatedValues","useSpring","useArcGenerator","_temp","_ref$cornerRadius","cornerRadius","_ref$padAngle","padAngle","d3Arc"],"sources":["/Users/parijatchatterjee/Desktop/TrailsExplore/node_modules/@nivo/arcs/src/arc_labels/ArcLabel.tsx","/Users/parijatchatterjee/Desktop/TrailsExplore/node_modules/@nivo/arcs/src/utils.ts","/Users/parijatchatterjee/Desktop/TrailsExplore/node_modules/@nivo/arcs/src/arcTransitionMode.ts","/Users/parijatchatterjee/Desktop/TrailsExplore/node_modules/@nivo/arcs/src/centers.ts","/Users/parijatchatterjee/Desktop/TrailsExplore/node_modules/@nivo/arcs/src/arc_labels/ArcLabelsLayer.tsx","/Users/parijatchatterjee/Desktop/TrailsExplore/node_modules/@nivo/arcs/src/arc_labels/canvas.ts","/Users/parijatchatterjee/Desktop/TrailsExplore/node_modules/@nivo/arcs/src/arc_labels/useArcLabels.ts","/Users/parijatchatterjee/Desktop/TrailsExplore/node_modules/@nivo/arcs/src/arc_labels/index.ts","/Users/parijatchatterjee/Desktop/TrailsExplore/node_modules/@nivo/arcs/src/arc_link_labels/ArcLinkLabel.tsx","/Users/parijatchatterjee/Desktop/TrailsExplore/node_modules/@nivo/arcs/src/arc_link_labels/compute.ts","/Users/parijatchatterjee/Desktop/TrailsExplore/node_modules/@nivo/arcs/src/arc_link_labels/useArcLinkLabelsTransition.ts","/Users/parijatchatterjee/Desktop/TrailsExplore/node_modules/@nivo/arcs/src/arc_link_labels/ArcLinkLabelsLayer.tsx","/Users/parijatchatterjee/Desktop/TrailsExplore/node_modules/@nivo/arcs/src/arc_link_labels/canvas.ts","/Users/parijatchatterjee/Desktop/TrailsExplore/node_modules/@nivo/arcs/src/arc_link_labels/useArcLinks.ts","/Users/parijatchatterjee/Desktop/TrailsExplore/node_modules/@nivo/arcs/src/arc_link_labels/useArcLinkLabels.ts","/Users/parijatchatterjee/Desktop/TrailsExplore/node_modules/@nivo/arcs/src/arc_link_labels/index.ts","/Users/parijatchatterjee/Desktop/TrailsExplore/node_modules/@nivo/arcs/src/ArcLine.tsx","/Users/parijatchatterjee/Desktop/TrailsExplore/node_modules/@nivo/arcs/src/ArcShape.tsx","/Users/parijatchatterjee/Desktop/TrailsExplore/node_modules/@nivo/arcs/src/interpolateArc.ts","/Users/parijatchatterjee/Desktop/TrailsExplore/node_modules/@nivo/arcs/src/useArcsTransition.ts","/Users/parijatchatterjee/Desktop/TrailsExplore/node_modules/@nivo/arcs/src/ArcsLayer.tsx","/Users/parijatchatterjee/Desktop/TrailsExplore/node_modules/@nivo/arcs/src/boundingBox.ts","/Users/parijatchatterjee/Desktop/TrailsExplore/node_modules/@nivo/arcs/src/interactivity.ts","/Users/parijatchatterjee/Desktop/TrailsExplore/node_modules/@nivo/arcs/src/useAnimatedArc.ts","/Users/parijatchatterjee/Desktop/TrailsExplore/node_modules/@nivo/arcs/src/useArcGenerator.ts"],"sourcesContent":["import { CSSProperties } from 'react'\nimport { SpringValue, Interpolation, animated } from '@react-spring/web'\nimport { useTheme } from '@nivo/core'\nimport { DatumWithArcAndColor } from '../types'\n\nconst staticStyle: CSSProperties = {\n    pointerEvents: 'none',\n}\n\nexport interface ArcLabelProps<Datum extends DatumWithArcAndColor> {\n    datum: Datum\n    label: string\n    style: {\n        progress: SpringValue<number>\n        transform: Interpolation<string>\n        textColor: string\n    }\n}\n\nexport const ArcLabel = <Datum extends DatumWithArcAndColor>({\n    label,\n    style,\n}: ArcLabelProps<Datum>) => {\n    const theme = useTheme()\n\n    return (\n        <animated.g transform={style.transform} opacity={style.progress} style={staticStyle}>\n            <animated.text\n                textAnchor=\"middle\"\n                dominantBaseline=\"central\"\n                style={{\n                    ...theme.labels.text,\n                    fill: style.textColor,\n                }}\n            >\n                {label}\n            </animated.text>\n        </animated.g>\n    )\n}\n","import { useMemo } from 'react'\nimport { radiansToDegrees, positionFromAngle, degreesToRadians } from '@nivo/core'\nimport { DatumWithArc } from './types'\n\n/**\n * Make sure an angle (expressed in radians)\n * always falls in the range 0~2*PI.\n */\nexport const getNormalizedAngle = (angle: number) => {\n    let normalizedAngle = angle % (Math.PI * 2)\n    if (normalizedAngle < 0) {\n        normalizedAngle += Math.PI * 2\n    }\n\n    return normalizedAngle\n}\n\n/**\n * Filter out arcs with a length below `skipAngle`.\n */\nexport const filterDataBySkipAngle = <Datum extends DatumWithArc>(\n    data: Datum[],\n    skipAngle: number\n) =>\n    data.filter(\n        datum => Math.abs(radiansToDegrees(datum.arc.endAngle - datum.arc.startAngle)) >= skipAngle\n    )\n\n/**\n * Memoized version of `filterDataBySkipAngle`.\n */\nexport const useFilteredDataBySkipAngle = <Datum extends DatumWithArc>(\n    data: Datum[],\n    skipAngle: number\n) => useMemo(() => filterDataBySkipAngle(data, skipAngle), [data, skipAngle])\n\nexport const svgEllipticalArcCommand = (\n    radius: number,\n    largeArcFlag: 0 | 1,\n    sweepFlag: 0 | 1,\n    x: number,\n    y: number\n) =>\n    [\n        'A',\n        radius,\n        radius,\n        0, // x-axis-rotation\n        largeArcFlag,\n        sweepFlag,\n        x,\n        y,\n    ].join(' ')\n\nexport const generateSvgArc = (\n    radius: number,\n    originalStartAngle: number,\n    originalEndAngle: number\n): string => {\n    const startAngle = Math.min(originalStartAngle, originalEndAngle)\n    const endAngle = Math.max(originalStartAngle, originalEndAngle)\n\n    const start = positionFromAngle(degreesToRadians(endAngle), radius)\n    const end = positionFromAngle(degreesToRadians(startAngle), radius)\n\n    // we have a full circle, we cannot use a single elliptical arc\n    // to draw it, so we use 2 in that case.\n    if (endAngle - startAngle >= 360) {\n        const mid = positionFromAngle(degreesToRadians(startAngle + 180), radius)\n\n        return [\n            `M ${start.x} ${start.y}`,\n            svgEllipticalArcCommand(radius, 1, 1, mid.x, mid.y),\n            `M ${start.x} ${start.y}`,\n            svgEllipticalArcCommand(radius, 1, 0, mid.x, mid.y),\n        ].join(' ')\n    }\n\n    const largeArcFlag = endAngle - startAngle <= 180 ? 0 : 1\n\n    return [\n        `M ${start.x} ${start.y}`,\n        svgEllipticalArcCommand(radius, largeArcFlag, 0, end.x, end.y),\n    ].join(' ')\n}\n","import { Arc, DatumWithArc } from './types'\nimport { useMemo } from 'react'\n\nexport interface ArcTransitionModeConfig {\n    enter: (arc: Arc) => Arc\n    update: (arc: Arc) => Arc\n    leave: (arc: Arc) => Arc\n}\n\nexport const arcTransitionModes = [\n    'startAngle',\n    'middleAngle',\n    'endAngle',\n    'innerRadius',\n    'centerRadius',\n    'outerRadius',\n    'pushIn',\n    'pushOut',\n] as const\nexport type ArcTransitionMode = (typeof arcTransitionModes)[number]\n\nexport const arcTransitionModeById: Record<ArcTransitionMode, ArcTransitionModeConfig> = {\n    startAngle: {\n        enter: (arc: Arc) => ({\n            ...arc,\n            endAngle: arc.startAngle,\n        }),\n        update: (arc: Arc) => arc,\n        leave: (arc: Arc) => ({\n            ...arc,\n            startAngle: arc.endAngle,\n        }),\n    },\n    middleAngle: {\n        enter: (arc: Arc) => {\n            const middleAngle = arc.startAngle + (arc.endAngle - arc.startAngle) / 2\n\n            return {\n                ...arc,\n                startAngle: middleAngle,\n                endAngle: middleAngle,\n            }\n        },\n        update: (arc: Arc) => arc,\n        leave: (arc: Arc) => {\n            const middleAngle = arc.startAngle + (arc.endAngle - arc.startAngle) / 2\n\n            return {\n                ...arc,\n                startAngle: middleAngle,\n                endAngle: middleAngle,\n            }\n        },\n    },\n    endAngle: {\n        enter: (arc: Arc) => ({\n            ...arc,\n            startAngle: arc.endAngle,\n        }),\n        update: (arc: Arc) => arc,\n        leave: (arc: Arc) => ({\n            ...arc,\n            endAngle: arc.startAngle,\n        }),\n    },\n    innerRadius: {\n        enter: (arc: Arc) => ({\n            ...arc,\n            outerRadius: arc.innerRadius,\n        }),\n        update: (arc: Arc) => arc,\n        leave: (arc: Arc) => ({\n            ...arc,\n            innerRadius: arc.outerRadius,\n        }),\n    },\n    centerRadius: {\n        enter: (arc: Arc) => {\n            const centerRadius = arc.innerRadius + (arc.outerRadius - arc.innerRadius) / 2\n\n            return {\n                ...arc,\n                innerRadius: centerRadius,\n                outerRadius: centerRadius,\n            }\n        },\n        update: (arc: Arc) => arc,\n        leave: (arc: Arc) => {\n            const centerRadius = arc.innerRadius + (arc.outerRadius - arc.innerRadius) / 2\n\n            return {\n                ...arc,\n                innerRadius: centerRadius,\n                outerRadius: centerRadius,\n            }\n        },\n    },\n    outerRadius: {\n        enter: (arc: Arc) => ({\n            ...arc,\n            innerRadius: arc.outerRadius,\n        }),\n        update: (arc: Arc) => arc,\n        leave: (arc: Arc) => ({\n            ...arc,\n            outerRadius: arc.innerRadius,\n        }),\n    },\n    pushIn: {\n        enter: (arc: Arc) => ({\n            ...arc,\n            innerRadius: arc.innerRadius - arc.outerRadius + arc.innerRadius,\n            outerRadius: arc.innerRadius,\n        }),\n        update: (arc: Arc) => arc,\n        leave: (arc: Arc) => ({\n            ...arc,\n            innerRadius: arc.outerRadius,\n            outerRadius: arc.outerRadius + arc.outerRadius - arc.innerRadius,\n        }),\n    },\n    pushOut: {\n        enter: (arc: Arc) => ({\n            ...arc,\n            innerRadius: arc.outerRadius,\n            outerRadius: arc.outerRadius + arc.outerRadius - arc.innerRadius,\n        }),\n        update: (arc: Arc) => arc,\n        leave: (arc: Arc) => ({\n            ...arc,\n            innerRadius: arc.innerRadius - arc.outerRadius + arc.innerRadius,\n            outerRadius: arc.innerRadius,\n        }),\n    },\n}\n\nexport interface TransitionExtra<Datum extends DatumWithArc, ExtraProps> {\n    enter: (datum: Datum) => ExtraProps\n    update: (datum: Datum) => ExtraProps\n    leave: (datum: Datum) => ExtraProps\n}\n\nexport const useArcTransitionMode = <Datum extends DatumWithArc, ExtraProps>(\n    mode: ArcTransitionMode,\n    extraTransition?: TransitionExtra<Datum, ExtraProps>\n) =>\n    useMemo(() => {\n        const transitionMode = arcTransitionModeById[mode]\n\n        return {\n            enter: (datum: Datum) => ({\n                progress: 0,\n                ...transitionMode.enter(datum.arc),\n                ...(extraTransition ? extraTransition.enter(datum) : {}),\n            }),\n            update: (datum: Datum) => ({\n                progress: 1,\n                ...transitionMode.update(datum.arc),\n                ...(extraTransition ? extraTransition.update(datum) : {}),\n            }),\n            leave: (datum: Datum) => ({\n                progress: 0,\n                ...transitionMode.leave(datum.arc),\n                ...(extraTransition ? extraTransition.leave(datum) : {}),\n            }),\n        }\n    }, [mode, extraTransition])\n","import { useMemo } from 'react'\nimport { useTransition, to, SpringValue } from '@react-spring/web'\nimport {\n    // @ts-ignore\n    midAngle,\n    positionFromAngle,\n    useMotionConfig,\n} from '@nivo/core'\nimport { Arc, DatumWithArc, Point } from './types'\nimport { filterDataBySkipAngle } from './utils'\nimport { ArcTransitionMode, TransitionExtra, useArcTransitionMode } from './arcTransitionMode'\n\nexport const computeArcCenter = (arc: Arc, offset: number): Point => {\n    const angle = midAngle(arc) - Math.PI / 2\n    const radius = arc.innerRadius + (arc.outerRadius - arc.innerRadius) * offset\n\n    return positionFromAngle(angle, radius)\n}\n\nexport const interpolateArcCenter =\n    (offset: number) =>\n    (\n        startAngleValue: SpringValue<number>,\n        endAngleValue: SpringValue<number>,\n        innerRadiusValue: SpringValue<number>,\n        outerRadiusValue: SpringValue<number>\n    ) =>\n        to(\n            [startAngleValue, endAngleValue, innerRadiusValue, outerRadiusValue],\n            (startAngle, endAngle, innerRadius, outerRadius) => {\n                const centroid = computeArcCenter(\n                    { startAngle, endAngle, innerRadius, outerRadius },\n                    offset\n                )\n\n                return `translate(${centroid.x},${centroid.y})`\n            }\n        )\n\nexport const useArcCentersTransition = <Datum extends DatumWithArc, ExtraProps = unknown>(\n    data: Datum[],\n    // define where the centers should be placed,\n    // 0.0: inner radius\n    // 0.5: center\n    // 1.0: outer radius\n    offset = 0.5,\n    mode: ArcTransitionMode = 'innerRadius',\n    extra?: TransitionExtra<Datum, ExtraProps>\n) => {\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const phases = useArcTransitionMode<Datum, ExtraProps>(mode, extra)\n\n    const transition = useTransition<\n        Datum,\n        {\n            progress: number\n            startAngle: number\n            endAngle: number\n            innerRadius: number\n            outerRadius: number\n        } & ExtraProps\n    >(data, {\n        keys: datum => datum.id,\n        initial: phases.update,\n        from: phases.enter,\n        enter: phases.update,\n        update: phases.update,\n        leave: phases.leave,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return {\n        transition,\n        interpolate: interpolateArcCenter(offset),\n    }\n}\n\nexport interface ArcCenter<Datum extends DatumWithArc> extends Point {\n    data: Datum\n}\n\n/**\n * Compute an array of arc centers from an array of data containing arcs.\n *\n * If you plan to animate those, you could use `useArcCentersTransition`\n * instead, you could use the returned array with react-spring `useTransition`,\n * but this would lead to cartesian transitions (x/y), while `useArcCentersTransition`\n * will generate proper transitions using radius/angle.\n */\nexport const useArcCenters = <\n    Datum extends DatumWithArc,\n    ExtraProps extends Record<string, any> = Record<string, any>\n>({\n    data,\n    offset = 0.5,\n    skipAngle = 0,\n    computeExtraProps = () => ({} as ExtraProps),\n}: {\n    data: Datum[]\n    // define where the centers should be placed,\n    // 0.0: inner radius\n    // 0.5: center\n    // 1.0: outer radius\n    offset?: number\n    // arcs with a length below this (end angle - start angle in degrees)\n    // are going to be excluded, this can typically be used to avoid having\n    // overlapping labels.\n    skipAngle?: number\n    // this can be used to append extra properties to the centers,\n    // can be used to compute a color/label for example.\n    computeExtraProps?: (datum: Datum) => ExtraProps\n}): (ArcCenter<Datum> & ExtraProps)[] =>\n    useMemo(\n        () =>\n            filterDataBySkipAngle<Datum>(data, skipAngle)\n                // compute position and extra props for each eligible datum\n                .map(datum => {\n                    const position = computeArcCenter(datum.arc, offset)\n\n                    return {\n                        ...computeExtraProps(datum),\n                        x: position.x,\n                        y: position.y,\n                        data: datum,\n                    }\n                }),\n        [data, offset, skipAngle, computeExtraProps]\n    )\n","import { createElement, useMemo } from 'react'\nimport { PropertyAccessor, usePropertyAccessor, radiansToDegrees, useTheme } from '@nivo/core'\nimport { useInheritedColor } from '@nivo/colors'\nimport { useArcCentersTransition } from '../centers'\nimport { ArcTransitionMode } from '../arcTransitionMode'\nimport { DatumWithArcAndColor } from '../types'\nimport { ArcLabelsProps } from './props'\nimport { ArcLabel, ArcLabelProps } from './ArcLabel'\n\nexport type ArcLabelComponent<Datum extends DatumWithArcAndColor> = (\n    props: ArcLabelProps<Datum>\n) => JSX.Element\n\ninterface ArcLabelsLayerProps<Datum extends DatumWithArcAndColor> {\n    center: [number, number]\n    data: Datum[]\n    label: PropertyAccessor<Datum, string>\n    radiusOffset: ArcLabelsProps<Datum>['arcLabelsRadiusOffset']\n    skipAngle: ArcLabelsProps<Datum>['arcLabelsSkipAngle']\n    textColor: ArcLabelsProps<Datum>['arcLabelsTextColor']\n    transitionMode: ArcTransitionMode\n    component?: ArcLabelsProps<Datum>['arcLabelsComponent']\n}\n\nexport const ArcLabelsLayer = <Datum extends DatumWithArcAndColor>({\n    center,\n    data,\n    transitionMode,\n    label: labelAccessor,\n    radiusOffset,\n    skipAngle,\n    textColor,\n    component = ArcLabel,\n}: ArcLabelsLayerProps<Datum>) => {\n    const getLabel = usePropertyAccessor<Datum, string>(labelAccessor)\n    const theme = useTheme()\n    const getTextColor = useInheritedColor<Datum>(textColor, theme)\n\n    const filteredData = useMemo(\n        () =>\n            data.filter(datum => {\n                return (\n                    Math.abs(radiansToDegrees(datum.arc.endAngle - datum.arc.startAngle)) >=\n                    skipAngle\n                )\n            }),\n        [data, skipAngle]\n    )\n\n    const { transition, interpolate } = useArcCentersTransition<Datum>(\n        filteredData,\n        radiusOffset,\n        transitionMode\n    )\n\n    const Label: ArcLabelComponent<Datum> = component\n\n    return (\n        <g transform={`translate(${center[0]},${center[1]})`}>\n            {transition((transitionProps, datum) => {\n                return createElement(Label, {\n                    key: datum.id,\n                    datum,\n                    label: getLabel(datum),\n                    style: {\n                        ...transitionProps,\n                        transform: interpolate(\n                            transitionProps.startAngle,\n                            transitionProps.endAngle,\n                            transitionProps.innerRadius,\n                            transitionProps.outerRadius\n                        ),\n                        textColor: getTextColor(datum),\n                    },\n                })\n            })}\n        </g>\n    )\n}\n","import { CompleteTheme } from '@nivo/core'\nimport { DatumWithArcAndColor } from '../types'\nimport { ArcLabel } from './useArcLabels'\n\nexport const drawCanvasArcLabels = <Datum extends DatumWithArcAndColor>(\n    ctx: CanvasRenderingContext2D,\n    labels: ArcLabel<Datum>[],\n    theme: CompleteTheme\n) => {\n    ctx.textAlign = 'center'\n    ctx.textBaseline = 'middle'\n    ctx.font = `${theme.labels.text.fontSize}px ${theme.labels.text.fontFamily}`\n\n    labels.forEach(label => {\n        ctx.fillStyle = label.textColor\n        ctx.fillText(`${label.label}`, label.x, label.y)\n    })\n}\n","import { useCallback } from 'react'\nimport { PropertyAccessor, usePropertyAccessor, useTheme } from '@nivo/core'\nimport { InheritedColorConfig, useInheritedColor } from '@nivo/colors'\nimport { DatumWithArcAndColor } from '../types'\nimport { useArcCenters, ArcCenter } from '../centers'\n\nexport interface ArcLabel<Datum extends DatumWithArcAndColor> extends ArcCenter<Datum> {\n    label: string\n    textColor: string\n}\n\n/**\n * Compute arc labels, please note that the datum should\n * contain a color in order to be able to compute the label text color.\n *\n * Please see `useArcCenters` for a more detailed explanation\n * about the parameters.\n */\nexport const useArcLabels = <Datum extends DatumWithArcAndColor>({\n    data,\n    offset,\n    skipAngle,\n    label,\n    textColor,\n}: {\n    data: Datum[]\n    offset?: number\n    skipAngle?: number\n    label: PropertyAccessor<Datum, string>\n    textColor: InheritedColorConfig<Datum>\n}) => {\n    const getLabel = usePropertyAccessor<Datum, string>(label)\n\n    const theme = useTheme()\n    const getTextColor = useInheritedColor<Datum>(textColor, theme)\n\n    const computeExtraProps = useCallback(\n        (datum: Datum) => {\n            return {\n                label: getLabel(datum),\n                textColor: getTextColor(datum),\n            }\n        },\n        [getLabel, getTextColor]\n    )\n\n    return useArcCenters<Datum, Omit<ArcLabel<Datum>, keyof ArcCenter<Datum>>>({\n        data,\n        offset,\n        skipAngle,\n        computeExtraProps,\n    })\n}\n","import { ArcLabel } from './ArcLabel'\n\nexport const ArcLabelComponent = ArcLabel\nexport * from './ArcLabelsLayer'\nexport * from './canvas'\nexport * from './props'\nexport * from './useArcLabels'\n","import { useTheme } from '@nivo/core'\nimport { SpringValue, Interpolation, animated } from '@react-spring/web'\nimport { DatumWithArcAndColor } from '../types'\n\nexport interface ArcLinkLabelProps<Datum extends DatumWithArcAndColor> {\n    datum: Datum\n    label: string\n    style: {\n        path: Interpolation<string>\n        thickness: number\n        textPosition: Interpolation<string>\n        textAnchor: Interpolation<'start' | 'end'>\n        linkColor: SpringValue<string>\n        opacity: SpringValue<number>\n        textColor: SpringValue<string>\n    }\n}\n\nexport const ArcLinkLabel = <Datum extends DatumWithArcAndColor>({\n    label,\n    style,\n}: ArcLinkLabelProps<Datum>) => {\n    const theme = useTheme()\n\n    return (\n        <animated.g opacity={style.opacity}>\n            <animated.path\n                fill=\"none\"\n                stroke={style.linkColor}\n                strokeWidth={style.thickness}\n                d={style.path}\n            />\n            <animated.text\n                transform={style.textPosition}\n                textAnchor={style.textAnchor}\n                dominantBaseline=\"central\"\n                style={{\n                    ...theme.labels.text,\n                    fill: style.textColor,\n                }}\n            >\n                {label}\n            </animated.text>\n        </animated.g>\n    )\n}\n","import { positionFromAngle } from '@nivo/core'\nimport { Arc, Point } from '../types'\nimport { getNormalizedAngle } from '../utils'\nimport { ArcLink } from './types'\n\n/**\n * Compute text anchor for a given arc.\n *\n * `computeArcLink` already computes a `side`, but when using\n * `react-spring`, you cannot have a single interpolation\n * returning several output values, so we need to compute\n * them in separate interpolations.\n */\nexport const computeArcLinkTextAnchor = (arc: Arc): 'start' | 'end' => {\n    const centerAngle = getNormalizedAngle(\n        arc.startAngle + (arc.endAngle - arc.startAngle) / 2 - Math.PI / 2\n    )\n\n    if (centerAngle < Math.PI / 2 || centerAngle > Math.PI * 1.5) {\n        return 'start'\n    }\n\n    return 'end'\n}\n\n/**\n * Compute the link of a single arc, returning its points,\n * please note that points coordinates are relative to\n * the center of the arc.\n */\nexport const computeArcLink = (\n    arc: Arc,\n    offset: number,\n    diagonalLength: number,\n    straightLength: number\n): ArcLink => {\n    const centerAngle = getNormalizedAngle(\n        arc.startAngle + (arc.endAngle - arc.startAngle) / 2 - Math.PI / 2\n    )\n    const point0: Point = positionFromAngle(centerAngle, arc.outerRadius + offset)\n    const point1: Point = positionFromAngle(centerAngle, arc.outerRadius + offset + diagonalLength)\n\n    let side: ArcLink['side']\n    let point2: Point\n    if (centerAngle < Math.PI / 2 || centerAngle > Math.PI * 1.5) {\n        side = 'after'\n        point2 = {\n            x: point1.x + straightLength,\n            y: point1.y,\n        }\n    } else {\n        side = 'before'\n        point2 = {\n            x: point1.x - straightLength,\n            y: point1.y,\n        }\n    }\n\n    return {\n        side,\n        points: [point0, point1, point2],\n    }\n}\n","import { useMemo } from 'react'\nimport { SpringValue, useTransition, to } from '@react-spring/web'\nimport { line } from 'd3-shape'\nimport { useMotionConfig, useTheme } from '@nivo/core'\nimport { InheritedColorConfig, useInheritedColor } from '@nivo/colors'\nimport { DatumWithArcAndColor, Point } from '../types'\nimport { useFilteredDataBySkipAngle } from '../utils'\nimport { computeArcLink, computeArcLinkTextAnchor } from './compute'\n\nconst lineGenerator = line<Point>()\n    .x(d => d.x)\n    .y(d => d.y)\n\ntype AnimatedProps = {\n    startAngle: number\n    endAngle: number\n    innerRadius: number\n    outerRadius: number\n    offset: number\n    diagonalLength: number\n    straightLength: number\n    textOffset: number\n    linkColor: string\n    textColor: string\n    opacity: number\n}\n\nconst useTransitionPhases = <Datum extends DatumWithArcAndColor>({\n    offset,\n    diagonalLength,\n    straightLength,\n    textOffset,\n    getLinkColor,\n    getTextColor,\n}: Pick<AnimatedProps, 'offset' | 'diagonalLength' | 'straightLength' | 'textOffset'> & {\n    getLinkColor: (datum: Datum) => string\n    getTextColor: (datum: Datum) => string\n}): Record<'enter' | 'update' | 'leave', (datum: Datum) => AnimatedProps> =>\n    useMemo(\n        () => ({\n            enter: (datum: Datum) => ({\n                startAngle: datum.arc.startAngle,\n                endAngle: datum.arc.endAngle,\n                innerRadius: datum.arc.innerRadius,\n                outerRadius: datum.arc.outerRadius,\n                offset,\n                diagonalLength: 0,\n                straightLength: 0,\n                textOffset,\n                linkColor: getLinkColor(datum),\n                textColor: getTextColor(datum),\n                opacity: 0,\n            }),\n            update: (d: Datum) => ({\n                startAngle: d.arc.startAngle,\n                endAngle: d.arc.endAngle,\n                innerRadius: d.arc.innerRadius,\n                outerRadius: d.arc.outerRadius,\n                offset,\n                diagonalLength,\n                straightLength,\n                textOffset,\n                linkColor: getLinkColor(d),\n                textColor: getTextColor(d),\n                opacity: 1,\n            }),\n            leave: (d: Datum) => ({\n                startAngle: d.arc.startAngle,\n                endAngle: d.arc.endAngle,\n                innerRadius: d.arc.innerRadius,\n                outerRadius: d.arc.outerRadius,\n                offset,\n                diagonalLength: 0,\n                straightLength: 0,\n                textOffset,\n                linkColor: getLinkColor(d),\n                textColor: getTextColor(d),\n                opacity: 0,\n            }),\n        }),\n        [diagonalLength, straightLength, textOffset, getLinkColor, getTextColor, offset]\n    )\n\nconst interpolateLink = (\n    startAngleValue: SpringValue<AnimatedProps['startAngle']>,\n    endAngleValue: SpringValue<AnimatedProps['endAngle']>,\n    innerRadiusValue: SpringValue<AnimatedProps['innerRadius']>,\n    outerRadiusValue: SpringValue<AnimatedProps['outerRadius']>,\n    offsetValue: SpringValue<AnimatedProps['offset']>,\n    diagonalLengthValue: SpringValue<AnimatedProps['diagonalLength']>,\n    straightLengthValue: SpringValue<AnimatedProps['straightLength']>\n) =>\n    to(\n        [\n            startAngleValue,\n            endAngleValue,\n            innerRadiusValue,\n            outerRadiusValue,\n            offsetValue,\n            diagonalLengthValue,\n            straightLengthValue,\n        ],\n        (\n            startAngle,\n            endAngle,\n            innerRadius,\n            outerRadius,\n            offset,\n            diagonalLengthAnimated,\n            straightLengthAnimated\n        ) => {\n            const { points } = computeArcLink(\n                {\n                    startAngle,\n                    endAngle,\n                    innerRadius,\n                    outerRadius,\n                },\n                offset,\n                diagonalLengthAnimated,\n                straightLengthAnimated\n            )\n\n            return lineGenerator(points)\n        }\n    )\n\nconst interpolateTextAnchor = (\n    startAngleValue: SpringValue<AnimatedProps['startAngle']>,\n    endAngleValue: SpringValue<AnimatedProps['endAngle']>,\n    innerRadiusValue: SpringValue<AnimatedProps['innerRadius']>,\n    outerRadiusValue: SpringValue<AnimatedProps['outerRadius']>\n) =>\n    to(\n        [startAngleValue, endAngleValue, innerRadiusValue, outerRadiusValue],\n        (startAngle, endAngle, innerRadius, outerRadius) => {\n            return computeArcLinkTextAnchor({\n                startAngle,\n                endAngle,\n                innerRadius,\n                outerRadius,\n            })\n        }\n    )\n\n/**\n * Interpolating the text position involves almost the same computation\n * as `interpolateLink`, unfortunately `react-spring` does not support\n * multiple output values from a single interpolation.\n *\n * We should revise this if `react-spring` adds this feature at some point.\n */\nconst interpolateTextPosition = (\n    startAngleValue: SpringValue<AnimatedProps['startAngle']>,\n    endAngleValue: SpringValue<AnimatedProps['endAngle']>,\n    innerRadiusValue: SpringValue<AnimatedProps['innerRadius']>,\n    outerRadiusValue: SpringValue<AnimatedProps['outerRadius']>,\n    offsetValue: SpringValue<AnimatedProps['offset']>,\n    diagonalLengthValue: SpringValue<AnimatedProps['diagonalLength']>,\n    straightLengthValue: SpringValue<AnimatedProps['straightLength']>,\n    textOffsetValue: SpringValue<AnimatedProps['textOffset']>\n) =>\n    to(\n        [\n            startAngleValue,\n            endAngleValue,\n            innerRadiusValue,\n            outerRadiusValue,\n            offsetValue,\n            diagonalLengthValue,\n            straightLengthValue,\n            textOffsetValue,\n        ],\n        (\n            startAngle,\n            endAngle,\n            innerRadius,\n            outerRadius,\n            offset,\n            diagonalLengthAnimated,\n            straightLengthAnimated,\n            textOffset\n        ) => {\n            const { points, side } = computeArcLink(\n                {\n                    startAngle,\n                    endAngle,\n                    innerRadius,\n                    outerRadius,\n                },\n                offset,\n                diagonalLengthAnimated,\n                straightLengthAnimated\n            )\n\n            const position = points[2]\n            if (side === 'before') {\n                position.x -= textOffset\n            } else {\n                position.x += textOffset\n            }\n\n            return `translate(${position.x},${position.y})`\n        }\n    )\n\n/**\n * This hook can be used to animate a group of arc link labels,\n * if you just want to compute the labels, please use `useArcLinkLabels`.\n */\nexport const useArcLinkLabelsTransition = <Datum extends DatumWithArcAndColor>({\n    data,\n    offset = 0,\n    diagonalLength,\n    straightLength,\n    skipAngle = 0,\n    textOffset,\n    linkColor,\n    textColor,\n}: {\n    data: Datum[]\n    offset?: number\n    diagonalLength: number\n    straightLength: number\n    skipAngle?: number\n    textOffset: number\n    linkColor: InheritedColorConfig<Datum>\n    textColor: InheritedColorConfig<Datum>\n}) => {\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const theme = useTheme()\n    const getLinkColor = useInheritedColor<Datum>(linkColor, theme)\n    const getTextColor = useInheritedColor<Datum>(textColor, theme)\n\n    const filteredData = useFilteredDataBySkipAngle<Datum>(data, skipAngle)\n    const transitionPhases = useTransitionPhases<Datum>({\n        offset,\n        diagonalLength,\n        straightLength,\n        textOffset,\n        getLinkColor,\n        getTextColor,\n    })\n\n    const transition = useTransition<Datum, AnimatedProps>(filteredData, {\n        keys: datum => datum.id,\n        initial: transitionPhases.update,\n        from: transitionPhases.enter,\n        enter: transitionPhases.update,\n        update: transitionPhases.update,\n        leave: transitionPhases.leave,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return {\n        transition,\n        interpolateLink,\n        interpolateTextAnchor,\n        interpolateTextPosition,\n    }\n}\n","import { createElement } from 'react'\nimport { usePropertyAccessor } from '@nivo/core'\nimport { DatumWithArcAndColor } from '../types'\nimport { useArcLinkLabelsTransition } from './useArcLinkLabelsTransition'\nimport { ArcLinkLabelsProps } from './props'\nimport { ArcLinkLabel, ArcLinkLabelProps } from './ArcLinkLabel'\n\nexport type ArcLinkLabelComponent<Datum extends DatumWithArcAndColor> = (\n    props: ArcLinkLabelProps<Datum>\n) => JSX.Element\n\ninterface ArcLinkLabelsLayerProps<Datum extends DatumWithArcAndColor> {\n    center: [number, number]\n    data: Datum[]\n    label: ArcLinkLabelsProps<Datum>['arcLinkLabel']\n    skipAngle: ArcLinkLabelsProps<Datum>['arcLinkLabelsSkipAngle']\n    offset: ArcLinkLabelsProps<Datum>['arcLinkLabelsOffset']\n    diagonalLength: ArcLinkLabelsProps<Datum>['arcLinkLabelsDiagonalLength']\n    straightLength: ArcLinkLabelsProps<Datum>['arcLinkLabelsStraightLength']\n    strokeWidth: ArcLinkLabelsProps<Datum>['arcLinkLabelsThickness']\n    textOffset: ArcLinkLabelsProps<Datum>['arcLinkLabelsTextOffset']\n    textColor: ArcLinkLabelsProps<Datum>['arcLinkLabelsTextColor']\n    linkColor: ArcLinkLabelsProps<Datum>['arcLinkLabelsColor']\n    component?: ArcLinkLabelComponent<Datum>\n}\n\nexport const ArcLinkLabelsLayer = <Datum extends DatumWithArcAndColor>({\n    center,\n    data,\n    label: labelAccessor,\n    skipAngle,\n    offset,\n    diagonalLength,\n    straightLength,\n    strokeWidth,\n    textOffset,\n    textColor,\n    linkColor,\n    component = ArcLinkLabel,\n}: ArcLinkLabelsLayerProps<Datum>) => {\n    const getLabel = usePropertyAccessor<Datum, string>(labelAccessor)\n\n    const { transition, interpolateLink, interpolateTextAnchor, interpolateTextPosition } =\n        useArcLinkLabelsTransition<Datum>({\n            data,\n            skipAngle,\n            offset,\n            diagonalLength,\n            straightLength,\n            textOffset,\n            linkColor,\n            textColor,\n        })\n\n    const Label: ArcLinkLabelComponent<Datum> = component\n\n    return (\n        <g transform={`translate(${center[0]},${center[1]})`}>\n            {transition((transitionProps, datum) => {\n                return createElement(Label, {\n                    key: datum.id,\n                    datum,\n                    label: getLabel(datum),\n                    style: {\n                        ...transitionProps,\n                        thickness: strokeWidth,\n                        path: interpolateLink(\n                            transitionProps.startAngle,\n                            transitionProps.endAngle,\n                            transitionProps.innerRadius,\n                            transitionProps.outerRadius,\n                            transitionProps.offset,\n                            transitionProps.diagonalLength,\n                            transitionProps.straightLength\n                        ),\n                        textAnchor: interpolateTextAnchor(\n                            transitionProps.startAngle,\n                            transitionProps.endAngle,\n                            transitionProps.innerRadius,\n                            transitionProps.outerRadius\n                        ),\n                        textPosition: interpolateTextPosition(\n                            transitionProps.startAngle,\n                            transitionProps.endAngle,\n                            transitionProps.innerRadius,\n                            transitionProps.outerRadius,\n                            transitionProps.offset,\n                            transitionProps.diagonalLength,\n                            transitionProps.straightLength,\n                            transitionProps.textOffset\n                        ),\n                    },\n                })\n            })}\n        </g>\n    )\n}\n","import {\n    // @ts-ignore\n    textPropsByEngine,\n    CompleteTheme,\n} from '@nivo/core'\nimport { DatumWithArcAndColor } from '../types'\nimport { ArcLinkLabel } from './types'\n\nexport const drawCanvasArcLinkLabels = <Datum extends DatumWithArcAndColor>(\n    ctx: CanvasRenderingContext2D,\n    labels: ArcLinkLabel<Datum>[],\n    theme: CompleteTheme,\n    strokeWidth: number\n) => {\n    ctx.textBaseline = 'middle'\n    ctx.font = `${theme.labels.text.fontSize}px ${theme.labels.text.fontFamily}`\n\n    labels.forEach(label => {\n        ctx.fillStyle = label.textColor\n        ctx.textAlign = textPropsByEngine.canvas.align[label.textAnchor]\n        ctx.fillText(`${label.label}`, label.x, label.y)\n\n        ctx.beginPath()\n        ctx.strokeStyle = label.linkColor\n        ctx.lineWidth = strokeWidth\n        label.points.forEach((point, index) => {\n            if (index === 0) ctx.moveTo(point.x, point.y)\n            else ctx.lineTo(point.x, point.y)\n        })\n        ctx.stroke()\n    })\n}\n","import { useMemo } from 'react'\nimport { radiansToDegrees } from '@nivo/core'\nimport { DatumWithArc } from '../types'\nimport { ArcLinkWithDatum } from './types'\nimport { computeArcLink } from './compute'\n\n/**\n * Compute links for an array of data containing arcs.\n *\n * This is typically used to create labels for arcs,\n * and it's used for the `useArcLinkLabels` hook.\n */\nexport const useArcLinks = <\n    Datum extends DatumWithArc,\n    ExtraProps extends Record<string, any> = Record<string, any>\n>({\n    data,\n    skipAngle = 0,\n    offset = 0.5,\n    diagonalLength,\n    straightLength,\n    computeExtraProps = () => ({} as ExtraProps),\n}: {\n    data: Datum[]\n    // arcs with a length below this (end angle - start angle in degrees)\n    // are going to be excluded, this can typically be used to avoid having\n    // overlapping labels.\n    skipAngle?: number\n    // offset from arc outer radius in pixels\n    offset?: number\n    // length of the diagonal segment of the link\n    diagonalLength: number\n    // length of the straight segment of the link\n    straightLength: number\n    // this can be used to append extra properties to the links,\n    // can be used to compute a color/label for example.\n    computeExtraProps?: (datum: ArcLinkWithDatum<Datum>) => ExtraProps\n}): (ArcLinkWithDatum<Datum> & ExtraProps)[] => {\n    const links = useMemo(\n        () =>\n            data\n                // filter out arcs with a length below `skipAngle`\n                .filter(\n                    datum =>\n                        Math.abs(radiansToDegrees(datum.arc.endAngle - datum.arc.startAngle)) >=\n                        skipAngle\n                )\n                // compute the link for each eligible arc\n                .map(datum => ({\n                    ...computeArcLink(datum.arc, offset, diagonalLength, straightLength),\n                    data: datum,\n                })),\n        [data, skipAngle, offset, diagonalLength, straightLength]\n    )\n\n    // splitting memoization of links and extra props can be more efficient,\n    // this way if only `computeExtraProps` changes, we skip links computation.\n    return useMemo(\n        () =>\n            links.map(link => ({\n                ...computeExtraProps(link),\n                ...link,\n            })),\n        [links, computeExtraProps]\n    )\n}\n","import { useCallback } from 'react'\nimport { PropertyAccessor, usePropertyAccessor, useTheme } from '@nivo/core'\nimport { InheritedColorConfig, useInheritedColor } from '@nivo/colors'\nimport { DatumWithArcAndColor } from '../types'\nimport { ArcLinkWithDatum, ArcLinkLabel } from './types'\nimport { useArcLinks } from './useArcLinks'\n\n/**\n * Compute arc link labels, please note that the datum should\n * contain a color in order to be able to compute the link/label text color.\n *\n * Please see `useArcLinks` for a more detailed explanation\n * about the parameters.\n */\nexport const useArcLinkLabels = <Datum extends DatumWithArcAndColor>({\n    data,\n    skipAngle,\n    offset,\n    diagonalLength,\n    straightLength,\n    textOffset = 0,\n    label,\n    linkColor,\n    textColor,\n}: {\n    data: Datum[]\n    skipAngle?: number\n    offset?: number\n    diagonalLength: number\n    straightLength: number\n    textOffset: number\n    label: PropertyAccessor<Datum, string>\n    linkColor: InheritedColorConfig<Datum>\n    textColor: InheritedColorConfig<Datum>\n}) => {\n    const getLabel = usePropertyAccessor<Datum, string>(label)\n\n    const theme = useTheme()\n    const getLinkColor = useInheritedColor<Datum>(linkColor, theme)\n    const getTextColor = useInheritedColor<Datum>(textColor, theme)\n\n    const computeExtraProps = useCallback(\n        (link: ArcLinkWithDatum<Datum>) => {\n            const position = {\n                x: link.points[2].x,\n                y: link.points[2].y,\n            }\n            let textAnchor: ArcLinkLabel<Datum>['textAnchor']\n            if (link.side === 'before') {\n                position.x -= textOffset\n                textAnchor = 'end'\n            } else {\n                position.x += textOffset\n                textAnchor = 'start'\n            }\n\n            return {\n                ...position,\n                label: getLabel(link.data),\n                linkColor: getLinkColor(link.data),\n                textAnchor,\n                textColor: getTextColor(link.data),\n            }\n        },\n        [getLabel, getLinkColor, getTextColor, textOffset]\n    )\n\n    return useArcLinks<Datum, Omit<ArcLinkLabel<Datum>, keyof ArcLinkWithDatum<Datum>>>({\n        data,\n        skipAngle,\n        offset,\n        diagonalLength,\n        straightLength,\n        computeExtraProps,\n    })\n}\n","import { ArcLinkLabel } from './ArcLinkLabel'\n\nexport const ArcLinkLabelComponent = ArcLinkLabel\nexport * from './ArcLinkLabelsLayer'\nexport * from './canvas'\nexport * from './compute'\nexport * from './props'\nexport * from './types'\nexport * from './useArcLinkLabels'\nexport * from './useArcLinkLabelsTransition'\nexport * from './useArcLinks'\n","import { animated, to, AnimatedProps } from '@react-spring/web'\nimport { ExtractProps } from '@nivo/core'\nimport { generateSvgArc } from './utils'\n\ntype ArcLineProps = {\n    animated: AnimatedProps<{\n        radius: number\n        startAngle: number\n        endAngle: number\n        opacity: number\n    }>\n} & ExtractProps<typeof animated.path>\n\nexport const ArcLine = ({ animated: animatedProps, ...rest }: ArcLineProps) => (\n    <animated.path\n        d={to(\n            [animatedProps.radius, animatedProps.startAngle, animatedProps.endAngle],\n            (radius, start, end) => generateSvgArc(radius, start, end)\n        )}\n        {...rest}\n    />\n)\n","import { useCallback, MouseEvent } from 'react'\nimport { SpringValue, Interpolation, animated } from '@react-spring/web'\nimport { DatumWithArcAndColor } from './types'\n\nexport type ArcMouseHandler<Datum extends DatumWithArcAndColor> = (\n    datum: Datum,\n    event: MouseEvent<SVGPathElement>\n) => void\n\nexport interface ArcShapeProps<Datum extends DatumWithArcAndColor> {\n    datum: Datum\n    style: {\n        opacity: SpringValue<number>\n        color: SpringValue<string>\n        borderWidth: number\n        borderColor: SpringValue<string>\n        path: Interpolation<string>\n    }\n    onClick?: ArcMouseHandler<Datum>\n    onMouseEnter?: ArcMouseHandler<Datum>\n    onMouseMove?: ArcMouseHandler<Datum>\n    onMouseLeave?: ArcMouseHandler<Datum>\n}\n\n/**\n * A simple arc component to be used typically with an `ArcsLayer`.\n *\n * Please note that the component accepts `SpringValue`s instead of\n * regular values to support animations.\n */\nexport const ArcShape = <Datum extends DatumWithArcAndColor>({\n    datum,\n    style,\n    onClick,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n}: ArcShapeProps<Datum>) => {\n    const handleClick = useCallback(\n        (event: MouseEvent<SVGPathElement>) => onClick?.(datum, event),\n        [onClick, datum]\n    )\n\n    const handleMouseEnter = useCallback(\n        (event: MouseEvent<SVGPathElement>) => onMouseEnter?.(datum, event),\n        [onMouseEnter, datum]\n    )\n\n    const handleMouseMove = useCallback(\n        (event: MouseEvent<SVGPathElement>) => onMouseMove?.(datum, event),\n        [onMouseMove, datum]\n    )\n\n    const handleMouseLeave = useCallback(\n        (event: MouseEvent<SVGPathElement>) => onMouseLeave?.(datum, event),\n        [onMouseLeave, datum]\n    )\n\n    return (\n        <animated.path\n            d={style.path}\n            opacity={style.opacity}\n            fill={datum.fill || style.color}\n            stroke={style.borderColor}\n            strokeWidth={style.borderWidth}\n            onClick={onClick ? handleClick : undefined}\n            onMouseEnter={onMouseEnter ? handleMouseEnter : undefined}\n            onMouseMove={onMouseMove ? handleMouseMove : undefined}\n            onMouseLeave={onMouseLeave ? handleMouseLeave : undefined}\n        />\n    )\n}\n","import { to, SpringValue } from '@react-spring/web'\nimport { ArcGenerator } from './types'\n\n/**\n * Directly animating paths for arcs leads to sub-optimal results\n * as the interpolation is going to be linear while we deal with polar coordinates,\n * this interpolator is going to generate proper arc transitions.\n * It should be used with the `useAnimatedArc` or `useArcsTransition` hooks.\n */\nexport const interpolateArc = (\n    startAngleValue: SpringValue<number>,\n    endAngleValue: SpringValue<number>,\n    innerRadiusValue: SpringValue<number>,\n    outerRadiusValue: SpringValue<number>,\n    arcGenerator: ArcGenerator\n) =>\n    to(\n        [startAngleValue, endAngleValue, innerRadiusValue, outerRadiusValue],\n        (startAngle, endAngle, innerRadius, outerRadius) => {\n            return arcGenerator({\n                startAngle,\n                endAngle,\n                innerRadius: Math.max(0, innerRadius),\n                outerRadius: Math.max(0, outerRadius),\n            })\n        }\n    )\n","import { useTransition } from '@react-spring/web'\nimport { useMotionConfig } from '@nivo/core'\nimport { DatumWithArc } from './types'\nimport { ArcTransitionMode, useArcTransitionMode, TransitionExtra } from './arcTransitionMode'\nimport { interpolateArc } from './interpolateArc'\n\n/**\n * This hook can be used to animate a group of arcs,\n * if you want to animate a single arc,\n * please have a look at the `useAnimatedArc` hook.\n */\nexport const useArcsTransition = <Datum extends DatumWithArc, ExtraProps = unknown>(\n    data: Datum[],\n    mode: ArcTransitionMode = 'innerRadius',\n    extra?: TransitionExtra<Datum, ExtraProps>\n) => {\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const phases = useArcTransitionMode<Datum, ExtraProps>(mode, extra)\n\n    const transition = useTransition<\n        Datum,\n        {\n            progress: number\n            startAngle: number\n            endAngle: number\n            innerRadius: number\n            outerRadius: number\n        } & ExtraProps\n    >(data, {\n        keys: datum => datum.id,\n        initial: phases.update,\n        from: phases.enter,\n        enter: phases.update,\n        update: phases.update,\n        leave: phases.leave,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return {\n        transition,\n        interpolate: interpolateArc,\n    }\n}\n","import { createElement } from 'react'\nimport { useTheme } from '@nivo/core'\nimport { InheritedColorConfig, useInheritedColor } from '@nivo/colors'\nimport { DatumWithArcAndColor, ArcGenerator } from './types'\nimport { useArcsTransition } from './useArcsTransition'\nimport { ArcTransitionMode } from './arcTransitionMode'\nimport { ArcMouseHandler, ArcShape, ArcShapeProps } from './ArcShape'\n\nexport type ArcComponent<Datum extends DatumWithArcAndColor> = (\n    props: ArcShapeProps<Datum>\n) => JSX.Element\n\ninterface ArcsLayerProps<Datum extends DatumWithArcAndColor> {\n    center: [number, number]\n    data: Datum[]\n    arcGenerator: ArcGenerator\n    borderWidth: number\n    borderColor: InheritedColorConfig<Datum>\n    onClick?: ArcMouseHandler<Datum>\n    onMouseEnter?: ArcMouseHandler<Datum>\n    onMouseMove?: ArcMouseHandler<Datum>\n    onMouseLeave?: ArcMouseHandler<Datum>\n    transitionMode: ArcTransitionMode\n    component?: ArcComponent<Datum>\n}\n\nexport const ArcsLayer = <Datum extends DatumWithArcAndColor>({\n    center,\n    data,\n    arcGenerator,\n    borderWidth,\n    borderColor,\n    onClick,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    transitionMode,\n    component = ArcShape,\n}: ArcsLayerProps<Datum>) => {\n    const theme = useTheme()\n    const getBorderColor = useInheritedColor<Datum>(borderColor, theme)\n\n    const { transition, interpolate } = useArcsTransition<\n        Datum,\n        {\n            opacity: number\n            color: string\n            borderColor: string\n        }\n    >(data, transitionMode, {\n        enter: datum => ({\n            opacity: 0,\n            color: datum.color,\n            borderColor: getBorderColor(datum),\n        }),\n        update: datum => ({\n            opacity: 1,\n            color: datum.color,\n            borderColor: getBorderColor(datum),\n        }),\n        leave: datum => ({\n            opacity: 0,\n            color: datum.color,\n            borderColor: getBorderColor(datum),\n        }),\n    })\n\n    const Arc: ArcComponent<Datum> = component\n\n    return (\n        <g transform={`translate(${center[0]},${center[1]})`}>\n            {transition((transitionProps, datum) => {\n                return createElement(Arc, {\n                    key: datum.id,\n                    datum,\n                    style: {\n                        ...transitionProps,\n                        borderWidth,\n                        path: interpolate(\n                            transitionProps.startAngle,\n                            transitionProps.endAngle,\n                            transitionProps.innerRadius,\n                            transitionProps.outerRadius,\n                            arcGenerator\n                        ),\n                    },\n                    onClick,\n                    onMouseEnter,\n                    onMouseMove,\n                    onMouseLeave,\n                })\n            })}\n        </g>\n    )\n}\n","import { positionFromAngle, degreesToRadians } from '@nivo/core'\n\n/**\n * Computes the bounding box for a circle arc.\n *\n * Assumptions:\n *   - Anywhere the arc intersects an axis will be a max or a min.\n *   - If the arc doesn't intersect an axis, then the center\n *     will be one corner of the bounding rectangle,\n *     and this is the only case when it will be.\n *   - The only other possible extreme points of the sector to consider\n *     are the endpoints of the radii.\n *\n * This script was built within the help of this answer on stackoverflow:\n *   https://stackoverflow.com/questions/1336663/2d-bounding-box-of-a-sector\n */\nexport const computeArcBoundingBox = (\n    centerX: number,\n    centerY: number,\n    radius: number,\n    // in degrees\n    startAngle: number,\n    // in degrees\n    endAngle: number,\n    includeCenter = true\n) => {\n    let points: [number, number][] = []\n\n    const p0 = positionFromAngle(degreesToRadians(startAngle), radius)\n    points.push([p0.x, p0.y])\n\n    const p1 = positionFromAngle(degreesToRadians(endAngle), radius)\n    points.push([p1.x, p1.y])\n\n    for (\n        let angle = Math.round(Math.min(startAngle, endAngle));\n        angle <= Math.round(Math.max(startAngle, endAngle));\n        angle++\n    ) {\n        if (angle % 90 === 0) {\n            const p = positionFromAngle(degreesToRadians(angle), radius)\n            points.push([p.x, p.y])\n        }\n    }\n\n    points = points.map(([x, y]) => [centerX + x, centerY + y])\n    if (includeCenter) {\n        points.push([centerX, centerY])\n    }\n\n    const xs = points.map(([x]) => x)\n    const ys = points.map(([, y]) => y)\n\n    const x0 = Math.min(...xs)\n    const x1 = Math.max(...xs)\n\n    const y0 = Math.min(...ys)\n    const y1 = Math.max(...ys)\n\n    return {\n        points,\n        x: x0,\n        y: y0,\n        width: x1 - x0,\n        height: y1 - y0,\n    }\n}\n","import { getDistance, getAngle } from '@nivo/core'\nimport { Arc } from './types'\n\n/**\n * Check if cursor is in given ring.\n */\nexport const isCursorInRing = (\n    centerX: number,\n    centerY: number,\n    radius: number,\n    innerRadius: number,\n    cursorX: number,\n    cursorY: number\n) => {\n    const distance = getDistance(cursorX, cursorY, centerX, centerY)\n\n    return distance < radius && distance > innerRadius\n}\n\n/**\n * Search for an arc being under cursor.\n */\nexport const findArcUnderCursor = <A extends Arc = Arc>(\n    centerX: number,\n    centerY: number,\n    radius: number,\n    innerRadius: number,\n    arcs: A[],\n    cursorX: number,\n    cursorY: number\n): A | undefined => {\n    if (!isCursorInRing(centerX, centerY, radius, innerRadius, cursorX, cursorY)) {\n        return undefined\n    }\n\n    const cursorAngle = getAngle(cursorX, cursorY, centerX, centerY)\n\n    return arcs.find(\n        ({ startAngle, endAngle }) => cursorAngle >= startAngle && cursorAngle < endAngle\n    )\n}\n","import { useSpring } from '@react-spring/web'\nimport { useMotionConfig } from '@nivo/core'\nimport { Arc, ArcGenerator } from './types'\nimport { interpolateArc } from './interpolateArc'\n\n/**\n * This hook can be used to animate a single arc,\n * if you want to animate a group of arcs,\n * please have a look at the `useArcsTransition` hook.\n */\nexport const useAnimatedArc = (datumWithArc: { arc: Arc }, arcGenerator: ArcGenerator) => {\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedValues = useSpring({\n        startAngle: datumWithArc.arc.startAngle,\n        endAngle: datumWithArc.arc.endAngle,\n        innerRadius: datumWithArc.arc.innerRadius,\n        outerRadius: datumWithArc.arc.outerRadius,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return {\n        ...animatedValues,\n        path: interpolateArc(\n            animatedValues.startAngle,\n            animatedValues.endAngle,\n            animatedValues.innerRadius,\n            animatedValues.outerRadius,\n            arcGenerator\n        ),\n    }\n}\n","import { useMemo } from 'react'\nimport { arc as d3Arc } from 'd3-shape'\nimport { ArcGenerator, Arc } from './types'\n\n/**\n * Memoize a d3 arc generator.\n *\n * Please note that both inner/outer radius aren't static\n * and should come from the arc itself, while it requires\n * more props on the arcs, it provides more flexibility\n * because it's not limited to pie then but can also work\n * with charts such as sunbursts.\n */\nexport const useArcGenerator = ({\n    cornerRadius = 0,\n    padAngle = 0,\n}: {\n    cornerRadius?: number\n    padAngle?: number\n} = {}): ArcGenerator =>\n    useMemo(\n        () =>\n            d3Arc<Arc>()\n                .innerRadius(arc => arc.innerRadius)\n                .outerRadius(arc => arc.outerRadius)\n                .cornerRadius(cornerRadius)\n                .padAngle(padAngle),\n        [cornerRadius, padAngle]\n    )\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}