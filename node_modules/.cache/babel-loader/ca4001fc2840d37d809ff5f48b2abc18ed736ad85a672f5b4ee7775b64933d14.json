{"ast":null,"code":"import { useMemo as n, Fragment as o, createElement as e, useRef as i, useState as t, useCallback as r } from \"react\";\nimport { Container as l, useDimensions as u, SvgWrapper as a, ResponsiveWrapper as d, getRelativeCursor as c } from \"@nivo/core\";\nimport { scaleLinear as s } from \"d3-scale\";\nimport { Delaunay as h } from \"d3-delaunay\";\nimport { jsx as f, jsxs as v, Fragment as p } from \"react/jsx-runtime\";\nfunction m() {\n  return m = Object.assign ? Object.assign.bind() : function (n) {\n    for (var o = 1; o < arguments.length; o++) {\n      var e = arguments[o];\n      for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]);\n    }\n    return n;\n  }, m.apply(this, arguments);\n}\nvar y = {\n    xDomain: [0, 1],\n    yDomain: [0, 1],\n    layers: [\"links\", \"cells\", \"points\", \"bounds\"],\n    enableLinks: !1,\n    linkLineWidth: 1,\n    linkLineColor: \"#bbbbbb\",\n    enableCells: !0,\n    cellLineWidth: 2,\n    cellLineColor: \"#000000\",\n    enablePoints: !0,\n    pointSize: 4,\n    pointColor: \"#666666\",\n    role: \"img\"\n  },\n  b = function (n) {\n    return \"function\" == typeof n ? n : function (o) {\n      return o[n];\n    };\n  },\n  g = function (n) {\n    var o = n.points,\n      e = n.x,\n      i = void 0 === e ? \"x\" : e,\n      t = n.y,\n      r = void 0 === t ? \"y\" : t,\n      l = b(i),\n      u = b(r);\n    return o.map(function (n) {\n      return [l(n), u(n)];\n    });\n  },\n  k = function (n) {\n    var o = n.points,\n      e = n.width,\n      i = n.height,\n      t = n.debug,\n      r = h.from(o),\n      l = t ? r.voronoi([0, 0, e, i]) : void 0;\n    return {\n      delaunay: r,\n      voronoi: l\n    };\n  },\n  C = function (o) {\n    var e = o.points,\n      i = o.x,\n      t = o.y,\n      r = o.width,\n      l = o.height,\n      u = o.debug,\n      a = n(function () {\n        return g({\n          points: e,\n          x: i,\n          y: t\n        });\n      }, [e, i, t]);\n    return n(function () {\n      return k({\n        points: a,\n        width: r,\n        height: l,\n        debug: u\n      });\n    }, [a, r, l, u]);\n  },\n  x = function (o) {\n    var e = o.data,\n      i = o.width,\n      t = o.height,\n      r = o.xDomain,\n      l = o.yDomain,\n      u = n(function () {\n        return s().domain(r).range([0, i]);\n      }, [r, i]),\n      a = n(function () {\n        return s().domain(l).range([0, t]);\n      }, [l, t]),\n      d = n(function () {\n        return e.map(function (n) {\n          return {\n            x: u(n.x),\n            y: a(n.y),\n            data: n\n          };\n        });\n      }, [e, u, a]);\n    return n(function () {\n      var n = h.from(d.map(function (n) {\n          return [n.x, n.y];\n        })),\n        o = n.voronoi([0, 0, i, t]);\n      return {\n        points: d,\n        delaunay: n,\n        voronoi: o\n      };\n    }, [d, i, t]);\n  },\n  L = function (o) {\n    var e = o.points,\n      i = o.delaunay,\n      t = o.voronoi;\n    return n(function () {\n      return {\n        points: e,\n        delaunay: i,\n        voronoi: t\n      };\n    }, [e, i, t]);\n  },\n  w = [\"theme\"],\n  W = function (n) {\n    var i = n.data,\n      t = n.width,\n      r = n.height,\n      l = n.margin,\n      d = n.layers,\n      c = void 0 === d ? y.layers : d,\n      s = n.xDomain,\n      h = void 0 === s ? y.xDomain : s,\n      v = n.yDomain,\n      p = void 0 === v ? y.yDomain : v,\n      m = n.enableLinks,\n      b = void 0 === m ? y.enableLinks : m,\n      g = n.linkLineWidth,\n      k = void 0 === g ? y.linkLineWidth : g,\n      C = n.linkLineColor,\n      w = void 0 === C ? y.linkLineColor : C,\n      W = n.enableCells,\n      D = void 0 === W ? y.enableCells : W,\n      M = n.cellLineWidth,\n      S = void 0 === M ? y.cellLineWidth : M,\n      T = n.cellLineColor,\n      O = void 0 === T ? y.cellLineColor : T,\n      P = n.enablePoints,\n      j = void 0 === P ? y.enableCells : P,\n      E = n.pointSize,\n      z = void 0 === E ? y.pointSize : E,\n      A = n.pointColor,\n      H = void 0 === A ? y.pointColor : A,\n      B = n.role,\n      F = void 0 === B ? y.role : B,\n      I = u(t, r, l),\n      q = I.outerWidth,\n      G = I.outerHeight,\n      J = I.margin,\n      K = I.innerWidth,\n      N = I.innerHeight,\n      Q = x({\n        data: i,\n        width: K,\n        height: N,\n        xDomain: h,\n        yDomain: p\n      }),\n      R = Q.points,\n      U = Q.delaunay,\n      V = Q.voronoi,\n      X = {\n        links: null,\n        cells: null,\n        points: null,\n        bounds: null\n      };\n    b && c.includes(\"links\") && (X.links = f(\"path\", {\n      stroke: w,\n      strokeWidth: k,\n      fill: \"none\",\n      d: U.render()\n    }, \"links\")), D && c.includes(\"cells\") && (X.cells = f(\"path\", {\n      d: V.render(),\n      fill: \"none\",\n      stroke: O,\n      strokeWidth: S\n    }, \"cells\")), j && c.includes(\"points\") && (X.points = f(\"path\", {\n      stroke: \"none\",\n      fill: H,\n      d: U.renderPoints(void 0, z / 2)\n    }, \"points\")), c.includes(\"bounds\") && (X.bounds = f(\"path\", {\n      fill: \"none\",\n      stroke: O,\n      strokeWidth: S,\n      d: V.renderBounds()\n    }, \"bounds\"));\n    var Y = L({\n      points: R,\n      delaunay: U,\n      voronoi: V\n    });\n    return f(a, {\n      width: q,\n      height: G,\n      margin: J,\n      role: F,\n      children: c.map(function (n, i) {\n        return void 0 !== X[n] ? X[n] : \"function\" == typeof n ? f(o, {\n          children: e(n, Y)\n        }, i) : null;\n      })\n    });\n  },\n  D = function (n) {\n    var o = n.theme,\n      e = function (n, o) {\n        if (null == n) return {};\n        var e,\n          i,\n          t = {},\n          r = Object.keys(n);\n        for (i = 0; i < r.length; i++) e = r[i], o.indexOf(e) >= 0 || (t[e] = n[e]);\n        return t;\n      }(n, w);\n    return f(l, {\n      isInteractive: !1,\n      animate: !1,\n      theme: o,\n      children: f(W, m({}, e))\n    });\n  },\n  M = function (n) {\n    return f(d, {\n      children: function (o) {\n        var e = o.width,\n          i = o.height;\n        return f(D, m({\n          width: e,\n          height: i\n        }, n));\n      }\n    });\n  },\n  S = function (o) {\n    var e = o.nodes,\n      l = o.width,\n      u = o.height,\n      a = o.x,\n      d = o.y,\n      s = o.onMouseEnter,\n      h = o.onMouseMove,\n      m = o.onMouseLeave,\n      y = o.onClick,\n      b = o.onTouchStart,\n      g = o.onTouchMove,\n      k = o.onTouchEnd,\n      x = o.enableTouchCrosshair,\n      L = void 0 !== x && x,\n      w = o.debug,\n      W = i(null),\n      D = t(null),\n      M = D[0],\n      S = D[1],\n      T = C({\n        points: e,\n        x: a,\n        y: d,\n        width: l,\n        height: u,\n        debug: w\n      }),\n      O = T.delaunay,\n      P = T.voronoi,\n      j = n(function () {\n        if (w && P) return P.render();\n      }, [w, P]),\n      E = r(function (n) {\n        if (!W.current) return [null, null];\n        var o = c(W.current, n),\n          i = o[0],\n          t = o[1],\n          r = O.find(i, t);\n        return [r, void 0 !== r ? e[r] : null];\n      }, [O, e]),\n      z = r(function (n) {\n        if (!W.current) return [null, null];\n        var o = c(W.current, n),\n          i = o[0],\n          t = o[1],\n          r = O.find(i, t);\n        return [r, void 0 !== r ? e[r] : null];\n      }, [O, e]),\n      A = r(function (n) {\n        var o = E(n),\n          e = o[0],\n          i = o[1];\n        S(e), i && (null == s || s(i, n));\n      }, [E, S, s]),\n      H = r(function (n) {\n        var o = E(n),\n          e = o[0],\n          i = o[1];\n        S(e), i && (null == h || h(i, n));\n      }, [E, S, h]),\n      B = r(function (n) {\n        if (S(null), m) {\n          var o = void 0;\n          null !== M && (o = e[M]), o && m(o, n);\n        }\n      }, [S, M, m, e]),\n      F = r(function (n) {\n        var o = E(n),\n          e = o[0],\n          i = o[1];\n        S(e), i && (null == y || y(i, n));\n      }, [E, S, y]),\n      I = r(function (n) {\n        var o = z(n),\n          e = o[0],\n          i = o[1];\n        L && S(e), i && (null == b || b(i, n));\n      }, [z, L, b]),\n      q = r(function (n) {\n        var o = z(n),\n          e = o[0],\n          i = o[1];\n        L && S(e), i && (null == g || g(i, n));\n      }, [z, L, g]),\n      G = r(function (n) {\n        if (L && S(null), k) {\n          var o = void 0;\n          null !== M && (o = e[M]), o && k(o, n);\n        }\n      }, [L, k, M, e]);\n    return v(\"g\", {\n      ref: W,\n      children: [w && P && v(p, {\n        children: [f(\"path\", {\n          d: j,\n          stroke: \"red\",\n          strokeWidth: 1,\n          opacity: .75\n        }), null !== M && f(\"path\", {\n          fill: \"pink\",\n          opacity: .35,\n          d: P.renderCell(M)\n        })]\n      }), f(\"rect\", {\n        \"data-ref\": \"mesh-interceptor\",\n        width: l,\n        height: u,\n        fill: \"red\",\n        opacity: 0,\n        style: {\n          cursor: \"auto\"\n        },\n        onMouseEnter: A,\n        onMouseMove: H,\n        onMouseLeave: B,\n        onTouchStart: I,\n        onTouchMove: q,\n        onTouchEnd: G,\n        onClick: F\n      })]\n    });\n  },\n  T = function (n, o) {\n    n.save(), n.globalAlpha = .75, n.beginPath(), o.render(n), n.strokeStyle = \"red\", n.lineWidth = 1, n.stroke(), n.restore();\n  },\n  O = function (n, o, e) {\n    n.save(), n.globalAlpha = .35, n.beginPath(), o.renderCell(e, n), n.fillStyle = \"red\", n.fill(), n.restore();\n  };\nexport { S as Mesh, M as ResponsiveVoronoi, D as Voronoi, k as computeMesh, g as computeMeshPoints, y as defaultVoronoiProps, O as renderVoronoiCellToCanvas, T as renderVoronoiToCanvas, x as useVoronoi, L as useVoronoiLayerContext, C as useVoronoiMesh };","map":{"version":3,"mappings":"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","names":["defaultVoronoiProps","xDomain","yDomain","layers","enableLinks","linkLineWidth","linkLineColor","enableCells","cellLineWidth","cellLineColor","enablePoints","pointSize","pointColor","role","getAccessor","directive","datum","computeMeshPoints","_ref","points","_ref$x","x","_ref$y","y","getX","getY","map","point","computeMesh","_ref2","width","height","debug","delaunay","Delaunay","from","voronoi","undefined","useVoronoiMesh","points2d","useMemo","useVoronoi","data","xScale","scaleLinear","domain","range","yScale","d","p","useVoronoiLayerContext","_ref3","w","InnerVoronoi","partialMargin","margin","_ref$layers","_ref$xDomain","_ref$yDomain","_ref$enableLinks","_ref$linkLineWidth","_ref$linkLineColor","_ref$enableCells","_ref$cellLineWidth","_ref$cellLineColor","_ref$enablePoints","_ref$pointSize","_ref$pointColor","_ref$role","_useDimensions","useDimensions","outerWidth","outerHeight","innerWidth","innerHeight","_useVoronoi","layerById","links","cells","bounds","includes","_jsx","stroke","strokeWidth","fill","render","renderPoints","renderBounds","layerContext","SvgWrapper","children","layer","i","Fragment","createElement","Voronoi","theme","otherProps","_objectWithoutPropertiesLoose","Container","isInteractive","animate","_extends","ResponsiveVoronoi","props","ResponsiveWrapper","Mesh","nodes","onMouseEnter","onMouseMove","onMouseLeave","onClick","onTouchStart","onTouchMove","onTouchEnd","_ref$enableTouchCross","enableTouchCrosshair","elementRef","useRef","_useState","useState","currentIndex","setCurrentIndex","_useVoronoiMesh","voronoiPath","getIndexAndNodeFromMouseEvent","useCallback","event","current","getRelativeCursor","_getRelativeCursor","index","find","getIndexAndNodeFromTouchEvent","_getRelativeCursor2","handleMouseEnter","_getIndexAndNodeFromM","node","handleMouseMove","_getIndexAndNodeFromM2","handleMouseLeave","previousNode","handleClick","_getIndexAndNodeFromM3","handleTouchStart","_getIndexAndNodeFromT","handleTouchMove","_getIndexAndNodeFromT2","handleTouchEnd","_jsxs","ref","opacity","renderCell","style","cursor","renderVoronoiToCanvas","ctx","save","globalAlpha","beginPath","strokeStyle","lineWidth","restore","renderVoronoiCellToCanvas","fillStyle"],"sources":["/Users/parijatchatterjee/Desktop/react-admin-dashboard/node_modules/@nivo/voronoi/src/props.ts","/Users/parijatchatterjee/Desktop/react-admin-dashboard/node_modules/@nivo/voronoi/src/computeMesh.ts","/Users/parijatchatterjee/Desktop/react-admin-dashboard/node_modules/@nivo/voronoi/src/hooks.ts","/Users/parijatchatterjee/Desktop/react-admin-dashboard/node_modules/@nivo/voronoi/src/Voronoi.tsx","/Users/parijatchatterjee/Desktop/react-admin-dashboard/node_modules/@nivo/voronoi/src/ResponsiveVoronoi.tsx","/Users/parijatchatterjee/Desktop/react-admin-dashboard/node_modules/@nivo/voronoi/src/Mesh.tsx","/Users/parijatchatterjee/Desktop/react-admin-dashboard/node_modules/@nivo/voronoi/src/meshCanvas.ts"],"sourcesContent":["import { VoronoiDomain, VoronoiLayer } from './types'\n\nexport const defaultVoronoiProps = {\n    xDomain: [0, 1] as VoronoiDomain,\n    yDomain: [0, 1] as VoronoiDomain,\n    layers: ['links', 'cells', 'points', 'bounds'] as VoronoiLayer[],\n    enableLinks: false,\n    linkLineWidth: 1,\n    linkLineColor: '#bbbbbb',\n    enableCells: true,\n    cellLineWidth: 2,\n    cellLineColor: '#000000',\n    enablePoints: true,\n    pointSize: 4,\n    pointColor: '#666666',\n    role: 'img',\n}\n","import { Delaunay } from 'd3-delaunay'\n\ntype NumberPropertyNames<T> = {\n    [K in keyof T]: T[K] extends number ? K : never\n}[keyof T]\n\nexport type XYAccessor<Datum> = NumberPropertyNames<Datum> | ((datum: Datum) => number)\n\nconst getAccessor = <Datum>(directive: XYAccessor<Datum>) =>\n    typeof directive === 'function' ? directive : (datum: Datum) => datum[directive]\n\n/**\n * The delaunay generator requires an array\n * where each point is defined as an array\n * of 2 elements: [x: number, y: number].\n *\n * Points represent the raw input data\n * and x/y represent accessors to x & y.\n */\nexport const computeMeshPoints = <Datum>({\n    points,\n    x = 'x' as NumberPropertyNames<Datum>,\n    y = 'y' as NumberPropertyNames<Datum>,\n}: {\n    points: Datum[]\n    x?: XYAccessor<Datum>\n    y?: XYAccessor<Datum>\n}): [number, number][] => {\n    const getX = getAccessor<Datum>(x)\n    const getY = getAccessor<Datum>(y)\n\n    return points.map(point => [getX(point) as number, getY(point) as number])\n}\n\nexport const computeMesh = ({\n    points,\n    width,\n    height,\n    debug,\n}: {\n    points: [number, number][]\n    width: number\n    height: number\n    debug?: boolean\n}) => {\n    const delaunay = Delaunay.from(points)\n    const voronoi = debug ? delaunay.voronoi([0, 0, width, height]) : undefined\n\n    return { delaunay, voronoi }\n}\n","import { useMemo } from 'react'\nimport { scaleLinear } from 'd3-scale'\nimport { Delaunay } from 'd3-delaunay'\nimport { computeMeshPoints, computeMesh, XYAccessor } from './computeMesh'\nimport { VoronoiCommonProps, VoronoiDatum, VoronoiCustomLayerProps } from './types'\n\nexport const useVoronoiMesh = <Datum>({\n    points,\n    x,\n    y,\n    width,\n    height,\n    debug,\n}: {\n    points: Datum[]\n    x?: XYAccessor<Datum>\n    y?: XYAccessor<Datum>\n    width: number\n    height: number\n    debug?: boolean\n}) => {\n    const points2d = useMemo(() => computeMeshPoints<Datum>({ points, x, y }), [points, x, y])\n\n    return useMemo(\n        () => computeMesh({ points: points2d, width, height, debug }),\n        [points2d, width, height, debug]\n    )\n}\n\nexport const useVoronoi = ({\n    data,\n    width,\n    height,\n    xDomain,\n    yDomain,\n}: {\n    data: VoronoiDatum[]\n    width: number\n    height: number\n    xDomain: VoronoiCommonProps['xDomain']\n    yDomain: VoronoiCommonProps['yDomain']\n}) => {\n    const xScale = useMemo(() => scaleLinear().domain(xDomain).range([0, width]), [xDomain, width])\n    const yScale = useMemo(\n        () => scaleLinear().domain(yDomain).range([0, height]),\n        [yDomain, height]\n    )\n\n    const points = useMemo(\n        () =>\n            data.map(d => ({\n                x: xScale(d.x),\n                y: yScale(d.y),\n                data: d,\n            })),\n        [data, xScale, yScale]\n    )\n\n    return useMemo(() => {\n        const delaunay = Delaunay.from(points.map(p => [p.x, p.y]))\n        const voronoi = delaunay.voronoi([0, 0, width, height])\n\n        return {\n            points,\n            delaunay,\n            voronoi,\n        }\n    }, [points, width, height])\n}\n\n/**\n * Memoize the context to pass to custom layers.\n */\nexport const useVoronoiLayerContext = ({\n    points,\n    delaunay,\n    voronoi,\n}: VoronoiCustomLayerProps): VoronoiCustomLayerProps =>\n    useMemo(\n        () => ({\n            points,\n            delaunay,\n            voronoi,\n        }),\n        [points, delaunay, voronoi]\n    )\n","import { createElement, Fragment, ReactNode } from 'react'\nimport { Container, SvgWrapper, useDimensions } from '@nivo/core'\nimport { VoronoiSvgProps, VoronoiLayerId } from './types'\nimport { defaultVoronoiProps } from './props'\nimport { useVoronoi, useVoronoiLayerContext } from './hooks'\n\ntype InnerVoronoiProps = Partial<Omit<VoronoiSvgProps, 'data' | 'width' | 'height'>> &\n    Pick<VoronoiSvgProps, 'data' | 'width' | 'height'>\n\nconst InnerVoronoi = ({\n    data,\n    width,\n    height,\n    margin: partialMargin,\n    layers = defaultVoronoiProps.layers,\n    xDomain = defaultVoronoiProps.xDomain,\n    yDomain = defaultVoronoiProps.yDomain,\n    enableLinks = defaultVoronoiProps.enableLinks,\n    linkLineWidth = defaultVoronoiProps.linkLineWidth,\n    linkLineColor = defaultVoronoiProps.linkLineColor,\n    enableCells = defaultVoronoiProps.enableCells,\n    cellLineWidth = defaultVoronoiProps.cellLineWidth,\n    cellLineColor = defaultVoronoiProps.cellLineColor,\n    enablePoints = defaultVoronoiProps.enableCells,\n    pointSize = defaultVoronoiProps.pointSize,\n    pointColor = defaultVoronoiProps.pointColor,\n    role = defaultVoronoiProps.role,\n}: InnerVoronoiProps) => {\n    const { outerWidth, outerHeight, margin, innerWidth, innerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const { points, delaunay, voronoi } = useVoronoi({\n        data,\n        width: innerWidth,\n        height: innerHeight,\n        xDomain,\n        yDomain,\n    })\n\n    const layerById: Record<VoronoiLayerId, ReactNode> = {\n        links: null,\n        cells: null,\n        points: null,\n        bounds: null,\n    }\n\n    if (enableLinks && layers.includes('links')) {\n        layerById.links = (\n            <path\n                key=\"links\"\n                stroke={linkLineColor}\n                strokeWidth={linkLineWidth}\n                fill=\"none\"\n                d={delaunay.render()}\n            />\n        )\n    }\n\n    if (enableCells && layers.includes('cells')) {\n        layerById.cells = (\n            <path\n                key=\"cells\"\n                d={voronoi.render()}\n                fill=\"none\"\n                stroke={cellLineColor}\n                strokeWidth={cellLineWidth}\n            />\n        )\n    }\n\n    if (enablePoints && layers.includes('points')) {\n        layerById.points = (\n            <path\n                key=\"points\"\n                stroke=\"none\"\n                fill={pointColor}\n                d={delaunay.renderPoints(undefined, pointSize / 2)}\n            />\n        )\n    }\n\n    if (layers.includes('bounds')) {\n        layerById.bounds = (\n            <path\n                key=\"bounds\"\n                fill=\"none\"\n                stroke={cellLineColor}\n                strokeWidth={cellLineWidth}\n                d={voronoi.renderBounds()}\n            />\n        )\n    }\n\n    const layerContext = useVoronoiLayerContext({\n        points,\n        delaunay,\n        voronoi,\n    })\n\n    return (\n        <SvgWrapper width={outerWidth} height={outerHeight} margin={margin} role={role}>\n            {layers.map((layer, i) => {\n                if (layerById[layer as VoronoiLayerId] !== undefined) {\n                    return layerById[layer as VoronoiLayerId]\n                }\n\n                if (typeof layer === 'function') {\n                    return <Fragment key={i}>{createElement(layer, layerContext)}</Fragment>\n                }\n\n                return null\n            })}\n        </SvgWrapper>\n    )\n}\n\nexport const Voronoi = ({\n    theme,\n    ...otherProps\n}: Partial<Omit<VoronoiSvgProps, 'data' | 'width' | 'height'>> &\n    Pick<VoronoiSvgProps, 'data' | 'width' | 'height'>) => (\n    <Container isInteractive={false} animate={false} theme={theme}>\n        <InnerVoronoi {...otherProps} />\n    </Container>\n)\n","import { ResponsiveWrapper } from '@nivo/core'\nimport { VoronoiSvgProps } from './types'\nimport { Voronoi } from './Voronoi'\n\ntype ResponsiveVoronoiProps = Partial<Omit<VoronoiSvgProps, 'data' | 'width' | 'height'>> &\n    Pick<VoronoiSvgProps, 'data'>\n\nexport const ResponsiveVoronoi = (props: ResponsiveVoronoiProps) => (\n    <ResponsiveWrapper>\n        {({ width, height }: { width: number; height: number }) => (\n            <Voronoi width={width} height={height} {...props} />\n        )}\n    </ResponsiveWrapper>\n)\n","import { useRef, useState, useCallback, useMemo, MouseEvent, TouchEvent } from 'react'\nimport { getRelativeCursor } from '@nivo/core'\nimport { useVoronoiMesh } from './hooks'\nimport { XYAccessor } from './computeMesh'\n\ntype MouseHandler<Datum> = (datum: Datum, event: MouseEvent) => void\ntype TouchHandler<Datum> = (datum: Datum, event: TouchEvent) => void\n\ninterface MeshProps<Datum> {\n    nodes: Datum[]\n    width: number\n    height: number\n    x?: XYAccessor<Datum>\n    y?: XYAccessor<Datum>\n    onMouseEnter?: MouseHandler<Datum>\n    onMouseMove?: MouseHandler<Datum>\n    onMouseLeave?: MouseHandler<Datum>\n    onClick?: MouseHandler<Datum>\n    onTouchStart?: TouchHandler<Datum>\n    onTouchMove?: TouchHandler<Datum>\n    onTouchEnd?: TouchHandler<Datum>\n    enableTouchCrosshair?: boolean\n    debug?: boolean\n}\n\nexport const Mesh = <Datum,>({\n    nodes,\n    width,\n    height,\n    x,\n    y,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n    enableTouchCrosshair = false,\n    debug,\n}: MeshProps<Datum>) => {\n    const elementRef = useRef<SVGGElement>(null)\n    const [currentIndex, setCurrentIndex] = useState<number | null>(null)\n\n    const { delaunay, voronoi } = useVoronoiMesh({\n        points: nodes,\n        x,\n        y,\n        width,\n        height,\n        debug,\n    })\n\n    const voronoiPath = useMemo(() => {\n        if (debug && voronoi) {\n            return voronoi.render()\n        }\n\n        return undefined\n    }, [debug, voronoi])\n\n    const getIndexAndNodeFromMouseEvent = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            if (!elementRef.current) {\n                return [null, null]\n            }\n\n            const [x, y] = getRelativeCursor(elementRef.current, event)\n            const index = delaunay.find(x, y)\n\n            return [index, index !== undefined ? nodes[index] : null] as [number, Datum | null]\n        },\n        [delaunay, nodes]\n    )\n\n    const getIndexAndNodeFromTouchEvent = useCallback(\n        (event: TouchEvent<SVGRectElement>) => {\n            if (!elementRef.current) {\n                return [null, null]\n            }\n\n            const [x, y] = getRelativeCursor(elementRef.current, event)\n            const index = delaunay.find(x, y)\n\n            return [index, index !== undefined ? nodes[index] : null] as [number, Datum | null]\n        },\n        [delaunay, nodes]\n    )\n\n    const handleMouseEnter = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            const [index, node] = getIndexAndNodeFromMouseEvent(event)\n            setCurrentIndex(index)\n            if (node) {\n                onMouseEnter?.(node, event)\n            }\n        },\n        [getIndexAndNodeFromMouseEvent, setCurrentIndex, onMouseEnter]\n    )\n\n    const handleMouseMove = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            const [index, node] = getIndexAndNodeFromMouseEvent(event)\n            setCurrentIndex(index)\n            if (node) {\n                onMouseMove?.(node, event)\n            }\n        },\n        [getIndexAndNodeFromMouseEvent, setCurrentIndex, onMouseMove]\n    )\n\n    const handleMouseLeave = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            setCurrentIndex(null)\n            if (onMouseLeave) {\n                let previousNode: Datum | undefined = undefined\n                if (currentIndex !== null) {\n                    previousNode = nodes[currentIndex]\n                }\n                previousNode && onMouseLeave(previousNode, event)\n            }\n        },\n        [setCurrentIndex, currentIndex, onMouseLeave, nodes]\n    )\n\n    const handleClick = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            const [index, node] = getIndexAndNodeFromMouseEvent(event)\n            setCurrentIndex(index)\n            if (node) {\n                onClick?.(node, event)\n            }\n        },\n        [getIndexAndNodeFromMouseEvent, setCurrentIndex, onClick]\n    )\n\n    const handleTouchStart = useCallback(\n        (event: TouchEvent<SVGRectElement>) => {\n            const [index, node] = getIndexAndNodeFromTouchEvent(event)\n            if (enableTouchCrosshair) {\n                setCurrentIndex(index)\n            }\n            if (node) {\n                onTouchStart?.(node, event)\n            }\n        },\n        [getIndexAndNodeFromTouchEvent, enableTouchCrosshair, onTouchStart]\n    )\n\n    const handleTouchMove = useCallback(\n        (event: TouchEvent<SVGRectElement>) => {\n            const [index, node] = getIndexAndNodeFromTouchEvent(event)\n            if (enableTouchCrosshair) {\n                setCurrentIndex(index)\n            }\n            if (node) {\n                onTouchMove?.(node, event)\n            }\n        },\n        [getIndexAndNodeFromTouchEvent, enableTouchCrosshair, onTouchMove]\n    )\n\n    const handleTouchEnd = useCallback(\n        (event: TouchEvent<SVGRectElement>) => {\n            if (enableTouchCrosshair) {\n                setCurrentIndex(null)\n            }\n            if (onTouchEnd) {\n                let previousNode: Datum | undefined = undefined\n                if (currentIndex !== null) {\n                    previousNode = nodes[currentIndex]\n                }\n                previousNode && onTouchEnd(previousNode, event)\n            }\n        },\n        [enableTouchCrosshair, onTouchEnd, currentIndex, nodes]\n    )\n\n    return (\n        <g ref={elementRef}>\n            {debug && voronoi && (\n                <>\n                    <path d={voronoiPath} stroke=\"red\" strokeWidth={1} opacity={0.75} />\n                    {/* highlight current cell */}\n                    {currentIndex !== null && (\n                        <path fill=\"pink\" opacity={0.35} d={voronoi.renderCell(currentIndex)} />\n                    )}\n                </>\n            )}\n            {/* transparent rect to intercept mouse events */}\n            <rect\n                data-ref=\"mesh-interceptor\"\n                width={width}\n                height={height}\n                fill=\"red\"\n                opacity={0}\n                style={{ cursor: 'auto' }}\n                onMouseEnter={handleMouseEnter}\n                onMouseMove={handleMouseMove}\n                onMouseLeave={handleMouseLeave}\n                onTouchStart={handleTouchStart}\n                onTouchMove={handleTouchMove}\n                onTouchEnd={handleTouchEnd}\n                onClick={handleClick}\n            />\n        </g>\n    )\n}\n","import { Delaunay, Voronoi } from 'd3-delaunay'\n\nexport const renderVoronoiToCanvas = (\n    ctx: CanvasRenderingContext2D,\n    voronoi: Voronoi<Delaunay.Point>\n) => {\n    ctx.save()\n\n    ctx.globalAlpha = 0.75\n    ctx.beginPath()\n    voronoi.render(ctx)\n    ctx.strokeStyle = 'red'\n    ctx.lineWidth = 1\n    ctx.stroke()\n\n    ctx.restore()\n}\n\nexport const renderVoronoiCellToCanvas = (\n    ctx: CanvasRenderingContext2D,\n    voronoi: Voronoi<Delaunay.Point>,\n    index: number\n) => {\n    ctx.save()\n\n    ctx.globalAlpha = 0.35\n    ctx.beginPath()\n    voronoi.renderCell(index, ctx)\n    ctx.fillStyle = 'red'\n    ctx.fill()\n\n    ctx.restore()\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}