{"ast":null,"code":"import { memo as e, useMemo as i, useId as o, useState as r, useCallback as n, createElement as t, Fragment as a, forwardRef as s, useRef as l, useEffect as u } from \"react\";\nimport { useTheme as d, lineCurvePropType as c, blendModePropType as h, motionPropTypes as f, defsPropTypes as p, curveFromProp as v, useValueFormatter as y, useMotionConfig as b, useAnimatedPath as m, getLabelGenerator as g, DotsItem as x, withContainer as R, useDimensions as T, CartesianMarkers as q, bindDefs as M, SvgWrapper as O, ResponsiveWrapper as S, getRelativeCursor as C, isCursorInRect as w } from \"@nivo/core\";\nimport { ordinalColorsPropType as k, useOrdinalColorScale as B, useInheritedColor as E } from \"@nivo/colors\";\nimport { axisPropType as L, Grid as W, Axes as G, renderGridLinesToCanvas as P, renderAxesToCanvas as j } from \"@nivo/axes\";\nimport { LegendPropShape as F, BoxLegendSvg as V, renderLegendToCanvas as Y } from \"@nivo/legends\";\nimport { BasicTooltip as D, TableTooltip as X, Chip as A, useTooltip as I, Crosshair as z } from \"@nivo/tooltip\";\nimport { line as H, area as J } from \"d3-shape\";\nimport { computeXYScalesForSeries as K } from \"@nivo/scales\";\nimport N from \"prop-types\";\nimport { jsx as Q, jsxs as U } from \"react/jsx-runtime\";\nimport { useSpring as Z, animated as $ } from \"@react-spring/web\";\nimport { Mesh as _, useVoronoiMesh as ee, renderVoronoiToCanvas as ie, renderVoronoiCellToCanvas as oe } from \"@nivo/voronoi\";\nfunction re() {\n  return re = Object.assign ? Object.assign.bind() : function (e) {\n    for (var i = 1; i < arguments.length; i++) {\n      var o = arguments[i];\n      for (var r in o) Object.prototype.hasOwnProperty.call(o, r) && (e[r] = o[r]);\n    }\n    return e;\n  }, re.apply(this, arguments);\n}\nvar ne = function (e) {\n  var i = e.point;\n  return Q(D, {\n    id: U(\"span\", {\n      children: [\"x: \", Q(\"strong\", {\n        children: i.data.xFormatted\n      }), \", y:\", \" \", Q(\"strong\", {\n        children: i.data.yFormatted\n      })]\n    }),\n    enableChip: !0,\n    color: i.serieColor\n  });\n};\nne.propTypes = {\n  point: N.object.isRequired\n};\nvar te = e(ne),\n  ae = function (e) {\n    var i = e.slice,\n      o = e.axis,\n      r = d(),\n      n = \"x\" === o ? \"y\" : \"x\";\n    return Q(X, {\n      rows: i.points.map(function (e) {\n        return [Q(A, {\n          color: e.serieColor,\n          style: r.tooltip.chip\n        }, \"chip\"), e.serieId, Q(\"span\", {\n          style: r.tooltip.tableCellValue,\n          children: e.data[n + \"Formatted\"]\n        }, \"value\")];\n      })\n    });\n  };\nae.propTypes = {\n  slice: N.object.isRequired,\n  axis: N.oneOf([\"x\", \"y\"]).isRequired\n};\nvar se = e(ae),\n  le = {\n    data: N.arrayOf(N.shape({\n      id: N.oneOfType([N.string, N.number]).isRequired,\n      data: N.arrayOf(N.shape({\n        x: N.oneOfType([N.number, N.string, N.instanceOf(Date)]),\n        y: N.oneOfType([N.number, N.string, N.instanceOf(Date)])\n      })).isRequired\n    })).isRequired,\n    xScale: N.object.isRequired,\n    xFormat: N.oneOfType([N.func, N.string]),\n    yScale: N.object.isRequired,\n    yFormat: N.oneOfType([N.func, N.string]),\n    layers: N.arrayOf(N.oneOfType([N.oneOf([\"grid\", \"markers\", \"axes\", \"areas\", \"crosshair\", \"lines\", \"slices\", \"points\", \"mesh\", \"legends\"]), N.func])).isRequired,\n    curve: c.isRequired,\n    axisTop: L,\n    axisRight: L,\n    axisBottom: L,\n    axisLeft: L,\n    enableGridX: N.bool.isRequired,\n    enableGridY: N.bool.isRequired,\n    gridXValues: N.oneOfType([N.number, N.arrayOf(N.oneOfType([N.number, N.string, N.instanceOf(Date)]))]),\n    gridYValues: N.oneOfType([N.number, N.arrayOf(N.oneOfType([N.number, N.string, N.instanceOf(Date)]))]),\n    enablePoints: N.bool.isRequired,\n    pointSymbol: N.func,\n    pointSize: N.number.isRequired,\n    pointColor: N.any.isRequired,\n    pointBorderWidth: N.number.isRequired,\n    pointBorderColor: N.any.isRequired,\n    enablePointLabel: N.bool.isRequired,\n    pointLabel: N.oneOfType([N.string, N.func]).isRequired,\n    markers: N.arrayOf(N.shape({\n      axis: N.oneOf([\"x\", \"y\"]).isRequired,\n      value: N.oneOfType([N.number, N.string, N.instanceOf(Date)]).isRequired,\n      style: N.object\n    })),\n    colors: k.isRequired,\n    enableArea: N.bool.isRequired,\n    areaOpacity: N.number.isRequired,\n    areaBlendMode: h.isRequired,\n    areaBaselineValue: N.oneOfType([N.number, N.string, N.instanceOf(Date)]).isRequired,\n    lineWidth: N.number.isRequired,\n    legends: N.arrayOf(N.shape(F)).isRequired,\n    isInteractive: N.bool.isRequired,\n    debugMesh: N.bool.isRequired,\n    tooltip: N.oneOfType([N.func, N.object]).isRequired,\n    enableSlices: N.oneOf([\"x\", \"y\", !1]).isRequired,\n    debugSlices: N.bool.isRequired,\n    sliceTooltip: N.oneOfType([N.func, N.object]).isRequired,\n    enableCrosshair: N.bool.isRequired,\n    crosshairType: N.string.isRequired\n  },\n  ue = re({}, le, {\n    enablePointLabel: N.bool.isRequired,\n    role: N.string.isRequired,\n    useMesh: N.bool.isRequired,\n    enableTouchCrosshair: N.bool\n  }, f, p),\n  de = re({\n    pixelRatio: N.number.isRequired\n  }, le),\n  ce = {\n    curve: \"linear\",\n    xScale: {\n      type: \"point\"\n    },\n    yScale: {\n      type: \"linear\",\n      min: 0,\n      max: \"auto\"\n    },\n    layers: [\"grid\", \"markers\", \"axes\", \"areas\", \"crosshair\", \"lines\", \"points\", \"slices\", \"mesh\", \"legends\"],\n    axisBottom: {},\n    axisLeft: {},\n    enableGridX: !0,\n    enableGridY: !0,\n    enablePoints: !0,\n    pointSize: 6,\n    pointColor: {\n      from: \"color\"\n    },\n    pointBorderWidth: 0,\n    pointBorderColor: {\n      theme: \"background\"\n    },\n    enablePointLabel: !1,\n    pointLabel: \"yFormatted\",\n    colors: {\n      scheme: \"nivo\"\n    },\n    enableArea: !1,\n    areaBaselineValue: 0,\n    areaOpacity: .2,\n    areaBlendMode: \"normal\",\n    lineWidth: 2,\n    legends: [],\n    isInteractive: !0,\n    tooltip: te,\n    enableSlices: !1,\n    debugSlices: !1,\n    sliceTooltip: se,\n    debugMesh: !1,\n    enableCrosshair: !0,\n    crosshairType: \"bottom-left\"\n  },\n  he = re({}, ce, {\n    enablePointLabel: !1,\n    useMesh: !1,\n    enableTouchCrosshair: !1,\n    animate: !0,\n    motionConfig: \"gentle\",\n    defs: [],\n    fill: [],\n    role: \"img\"\n  }),\n  fe = re({}, ce, {\n    pixelRatio: \"undefined\" != typeof window && window.devicePixelRatio || 1\n  }),\n  pe = function (e) {\n    var o = e.curve;\n    return i(function () {\n      return H().defined(function (e) {\n        return null !== e.x && null !== e.y;\n      }).x(function (e) {\n        return e.x;\n      }).y(function (e) {\n        return e.y;\n      }).curve(v(o));\n    }, [o]);\n  },\n  ve = function (e) {\n    var o = e.curve,\n      r = e.yScale,\n      n = e.areaBaselineValue;\n    return i(function () {\n      return J().defined(function (e) {\n        return null !== e.x && null !== e.y;\n      }).x(function (e) {\n        return e.x;\n      }).y1(function (e) {\n        return e.y;\n      }).curve(v(o)).y0(r(n));\n    }, [o, r, n]);\n  },\n  ye = function (e) {\n    var o = e.componentId,\n      r = e.enableSlices,\n      n = e.points,\n      t = e.width,\n      a = e.height;\n    return i(function () {\n      if (!1 === r) return [];\n      if (\"x\" === r) {\n        var e = new Map();\n        return n.forEach(function (i) {\n          null !== i.data.x && null !== i.data.y && (e.has(i.x) ? e.get(i.x).push(i) : e.set(i.x, [i]));\n        }), Array.from(e.entries()).sort(function (e, i) {\n          return e[0] - i[0];\n        }).map(function (e, i, r) {\n          var n,\n            s,\n            l = e[0],\n            u = e[1],\n            d = r[i - 1],\n            c = r[i + 1];\n          return n = d ? l - (l - d[0]) / 2 : l, s = c ? l - n + (c[0] - l) / 2 : t - n, {\n            id: \"slice\" + o + l,\n            x0: n,\n            x: l,\n            y0: 0,\n            y: 0,\n            width: s,\n            height: a,\n            points: u.reverse()\n          };\n        });\n      }\n      if (\"y\" === r) {\n        var i = new Map();\n        return n.forEach(function (e) {\n          null !== e.data.x && null !== e.data.y && (i.has(e.y) ? i.get(e.y).push(e) : i.set(e.y, [e]));\n        }), Array.from(i.entries()).sort(function (e, i) {\n          return e[0] - i[0];\n        }).map(function (e, i, o) {\n          var r,\n            n,\n            s = e[0],\n            l = e[1],\n            u = o[i - 1],\n            d = o[i + 1];\n          return r = u ? s - (s - u[0]) / 2 : s, n = d ? s - r + (d[0] - s) / 2 : a - r, {\n            id: s,\n            x0: 0,\n            x: 0,\n            y0: r,\n            y: s,\n            width: t,\n            height: n,\n            points: l.reverse()\n          };\n        });\n      }\n    }, [o, r, a, n, t]);\n  },\n  be = function (e) {\n    var t = e.data,\n      a = e.xScale,\n      s = void 0 === a ? he.xScale : a,\n      l = e.xFormat,\n      u = e.yScale,\n      c = void 0 === u ? he.yScale : u,\n      h = e.yFormat,\n      f = e.width,\n      p = e.height,\n      v = e.colors,\n      b = void 0 === v ? he.colors : v,\n      m = e.curve,\n      g = void 0 === m ? he.curve : m,\n      x = e.areaBaselineValue,\n      R = void 0 === x ? he.areaBaselineValue : x,\n      T = e.pointColor,\n      q = void 0 === T ? he.pointColor : T,\n      M = e.pointBorderColor,\n      O = void 0 === M ? he.pointBorderColor : M,\n      S = e.enableSlices,\n      C = void 0 === S ? he.enableSlicesTooltip : S,\n      w = o(),\n      k = y(l),\n      L = y(h),\n      W = B(b, \"id\"),\n      G = d(),\n      P = E(q, G),\n      j = E(O, G),\n      F = r([]),\n      V = F[0],\n      Y = F[1],\n      D = i(function () {\n        return K(t.filter(function (e) {\n          return -1 === V.indexOf(e.id);\n        }), s, c, f, p);\n      }, [t, V, s, c, f, p]),\n      X = D.xScale,\n      A = D.yScale,\n      I = D.series,\n      z = i(function () {\n        var e = t.map(function (e) {\n            return {\n              id: e.id,\n              label: e.id,\n              color: W(e)\n            };\n          }),\n          i = e.map(function (e) {\n            return re({}, I.find(function (i) {\n              return i.id === e.id;\n            }), {\n              color: e.color\n            });\n          }).filter(function (e) {\n            return Boolean(e.id);\n          });\n        return {\n          legendData: e.map(function (e) {\n            return re({}, e, {\n              hidden: !i.find(function (i) {\n                return i.id === e.id;\n              })\n            });\n          }).reverse(),\n          series: i\n        };\n      }, [t, I, W]),\n      H = z.legendData,\n      J = z.series,\n      N = n(function (e) {\n        Y(function (i) {\n          return i.indexOf(e) > -1 ? i.filter(function (i) {\n            return i !== e;\n          }) : [].concat(i, [e]);\n        });\n      }, []),\n      Q = function (e) {\n        var o = e.series,\n          r = e.getPointColor,\n          n = e.getPointBorderColor,\n          t = e.formatX,\n          a = e.formatY;\n        return i(function () {\n          return o.reduce(function (e, i) {\n            return [].concat(e, i.data.filter(function (e) {\n              return null !== e.position.x && null !== e.position.y;\n            }).map(function (o, s) {\n              var l = {\n                id: i.id + \".\" + s,\n                index: e.length + s,\n                serieId: i.id,\n                serieColor: i.color,\n                x: o.position.x,\n                y: o.position.y\n              };\n              return l.color = r(i), l.borderColor = n(l), l.data = re({}, o.data, {\n                xFormatted: t(o.data.x),\n                yFormatted: a(o.data.y)\n              }), l;\n            }));\n          }, []);\n        }, [o, r, n, t, a]);\n      }({\n        series: J,\n        getPointColor: P,\n        getPointBorderColor: j,\n        formatX: k,\n        formatY: L\n      }),\n      U = ye({\n        componentId: w,\n        enableSlices: C,\n        points: Q,\n        width: f,\n        height: p\n      });\n    return {\n      legendData: H,\n      toggleSerie: N,\n      lineGenerator: pe({\n        curve: g\n      }),\n      areaGenerator: ve({\n        curve: g,\n        yScale: A,\n        areaBaselineValue: R\n      }),\n      getColor: W,\n      series: J,\n      xScale: X,\n      yScale: A,\n      slices: U,\n      points: Q\n    };\n  },\n  me = function (e) {\n    var i = e.areaBlendMode,\n      o = e.areaOpacity,\n      r = e.color,\n      n = e.fill,\n      t = e.path,\n      a = b(),\n      s = a.animate,\n      l = a.config,\n      u = m(t),\n      d = Z({\n        color: r,\n        config: l,\n        immediate: !s\n      });\n    return Q($.path, {\n      d: u,\n      fill: n || d.color,\n      fillOpacity: o,\n      strokeWidth: 0,\n      style: {\n        mixBlendMode: i\n      }\n    });\n  };\nme.propTypes = {\n  areaBlendMode: h.isRequired,\n  areaOpacity: N.number.isRequired,\n  color: N.string,\n  fill: N.string,\n  path: N.string.isRequired\n};\nvar ge = function (e) {\n  var i = e.areaGenerator,\n    o = e.areaOpacity,\n    r = e.areaBlendMode,\n    n = e.lines.slice(0).reverse();\n  return Q(\"g\", {\n    children: n.map(function (e) {\n      return Q(me, re({\n        path: i(e.data.map(function (e) {\n          return e.position;\n        }))\n      }, re({\n        areaOpacity: o,\n        areaBlendMode: r\n      }, e)), e.id);\n    })\n  });\n};\nge.propTypes = {\n  areaGenerator: N.func.isRequired,\n  areaOpacity: N.number.isRequired,\n  areaBlendMode: h.isRequired,\n  lines: N.arrayOf(N.object).isRequired\n};\nvar xe = e(ge),\n  Re = function (e) {\n    var o = e.lineGenerator,\n      r = e.points,\n      n = e.color,\n      t = e.thickness,\n      a = i(function () {\n        return o(r);\n      }, [o, r]),\n      s = m(a);\n    return Q($.path, {\n      d: s,\n      fill: \"none\",\n      strokeWidth: t,\n      stroke: n\n    });\n  };\nRe.propTypes = {\n  points: N.arrayOf(N.shape({\n    x: N.oneOfType([N.string, N.number]),\n    y: N.oneOfType([N.string, N.number])\n  })),\n  lineGenerator: N.func.isRequired,\n  color: N.string.isRequired,\n  thickness: N.number.isRequired\n};\nvar Te = e(Re),\n  qe = function (e) {\n    var i = e.lines,\n      o = e.lineGenerator,\n      r = e.lineWidth;\n    return i.slice(0).reverse().map(function (e) {\n      var i = e.id,\n        n = e.data,\n        t = e.color;\n      return Q(Te, {\n        id: i,\n        points: n.map(function (e) {\n          return e.position;\n        }),\n        lineGenerator: o,\n        color: t,\n        thickness: r\n      }, i);\n    });\n  };\nqe.propTypes = {\n  lines: N.arrayOf(N.shape({\n    id: N.oneOfType([N.string, N.number]).isRequired,\n    color: N.string.isRequired,\n    data: N.arrayOf(N.shape({\n      data: N.shape({\n        x: N.oneOfType([N.string, N.number, N.instanceOf(Date)]),\n        y: N.oneOfType([N.string, N.number, N.instanceOf(Date)])\n      }).isRequired,\n      position: N.shape({\n        x: N.number,\n        y: N.number\n      }).isRequired\n    })).isRequired\n  })).isRequired,\n  lineWidth: N.number.isRequired,\n  lineGenerator: N.func.isRequired\n};\nvar Me = e(qe),\n  Oe = function (e) {\n    var i = e.slice,\n      o = e.slices,\n      r = e.axis,\n      a = e.debug,\n      s = e.tooltip,\n      l = e.isCurrent,\n      u = e.setCurrent,\n      d = e.onMouseEnter,\n      c = e.onMouseMove,\n      h = e.onMouseLeave,\n      f = e.onClick,\n      p = e.onTouchStart,\n      v = e.onTouchMove,\n      y = e.onTouchEnd,\n      b = I(),\n      m = b.showTooltipFromEvent,\n      g = b.hideTooltip,\n      x = n(function (e) {\n        m(t(s, {\n          slice: i,\n          axis: r\n        }), e, \"right\"), u(i), d && d(i, e);\n      }, [m, s, i, r, u, d]),\n      R = n(function (e) {\n        m(t(s, {\n          slice: i,\n          axis: r\n        }), e, \"right\"), c && c(i, e);\n      }, [m, s, i, r, c]),\n      T = n(function (e) {\n        g(), u(null), h && h(i, e);\n      }, [g, u, h, i]),\n      q = n(function (e) {\n        f && f(i, e);\n      }, [i, f]),\n      M = n(function (e) {\n        m(t(s, {\n          slice: i,\n          axis: r\n        }), e, \"right\"), u(i), p && p(i, e);\n      }, [r, p, u, m, i, s]),\n      O = n(function (e) {\n        var n = e.touches[0],\n          a = document.elementFromPoint(n.clientX, n.clientY),\n          l = null == a ? void 0 : a.getAttribute(\"data-ref\");\n        if (l) {\n          var d = o.find(function (e) {\n            return e.id === l;\n          });\n          d && (m(t(s, {\n            slice: d,\n            axis: r\n          }), e, \"right\"), u(d));\n        }\n        v && v(i, e);\n      }, [r, v, u, m, i, o, s]),\n      S = n(function (e) {\n        g(), u(null), y && y(i, e);\n      }, [g, u, y, i]);\n    return Q(\"rect\", {\n      x: i.x0,\n      y: i.y0,\n      width: i.width,\n      height: i.height,\n      stroke: \"red\",\n      strokeWidth: a ? 1 : 0,\n      strokeOpacity: .75,\n      fill: \"red\",\n      fillOpacity: l && a ? .35 : 0,\n      onMouseEnter: x,\n      onMouseMove: R,\n      onMouseLeave: T,\n      onClick: q,\n      onTouchStart: M,\n      onTouchMove: O,\n      onTouchEnd: S,\n      \"data-ref\": i.id\n    });\n  };\nOe.propTypes = {\n  slice: N.object.isRequired,\n  slices: N.arrayOf(N.object).isRequired,\n  axis: N.oneOf([\"x\", \"y\"]).isRequired,\n  debug: N.bool.isRequired,\n  height: N.number.isRequired,\n  tooltip: N.oneOfType([N.func, N.object]),\n  isCurrent: N.bool.isRequired,\n  setCurrent: N.func.isRequired,\n  onMouseEnter: N.func,\n  onMouseMove: N.func,\n  onMouseLeave: N.func,\n  onClick: N.func\n};\nvar Se = e(Oe),\n  Ce = function (e) {\n    var i = e.slices,\n      o = e.axis,\n      r = e.debug,\n      n = e.height,\n      t = e.tooltip,\n      a = e.current,\n      s = e.setCurrent,\n      l = e.onMouseEnter,\n      u = e.onMouseMove,\n      d = e.onMouseLeave,\n      c = e.onClick,\n      h = e.onTouchStart,\n      f = e.onTouchMove,\n      p = e.onTouchEnd;\n    return i.map(function (e) {\n      return Q(Se, {\n        slice: e,\n        slices: i,\n        axis: o,\n        debug: r,\n        height: n,\n        tooltip: t,\n        setCurrent: s,\n        isCurrent: null !== a && a.id === e.id,\n        onMouseEnter: l,\n        onMouseMove: u,\n        onMouseLeave: d,\n        onClick: c,\n        onTouchStart: h,\n        onTouchMove: f,\n        onTouchEnd: p\n      }, e.id);\n    });\n  };\nCe.propTypes = {\n  slices: N.arrayOf(N.shape({\n    id: N.oneOfType([N.number, N.string, N.instanceOf(Date)]).isRequired,\n    x: N.number.isRequired,\n    y: N.number.isRequired,\n    points: N.arrayOf(N.object).isRequired\n  })).isRequired,\n  axis: N.oneOf([\"x\", \"y\"]).isRequired,\n  debug: N.bool.isRequired,\n  height: N.number.isRequired,\n  tooltip: N.oneOfType([N.func, N.object]).isRequired,\n  current: N.object,\n  setCurrent: N.func.isRequired,\n  onMouseEnter: N.func,\n  onMouseMove: N.func,\n  onMouseLeave: N.func,\n  onClick: N.func,\n  onTouchStart: N.func,\n  onTouchMove: N.func,\n  onTouchEnd: N.func\n};\nvar we = e(Ce),\n  ke = function (e) {\n    var i = e.points,\n      o = e.symbol,\n      r = e.size,\n      n = e.borderWidth,\n      t = e.enableLabel,\n      a = e.label,\n      s = e.labelYOffset,\n      l = d(),\n      u = g(a),\n      c = i.slice(0).reverse().map(function (e) {\n        return {\n          id: e.id,\n          x: e.x,\n          y: e.y,\n          datum: e.data,\n          fill: e.color,\n          stroke: e.borderColor,\n          label: t ? u(e.data) : null\n        };\n      });\n    return Q(\"g\", {\n      children: c.map(function (e) {\n        return Q(x, {\n          x: e.x,\n          y: e.y,\n          datum: e.datum,\n          symbol: o,\n          size: r,\n          color: e.fill,\n          borderWidth: n,\n          borderColor: e.stroke,\n          label: e.label,\n          labelYOffset: s,\n          theme: l\n        }, e.id);\n      })\n    });\n  };\nke.propTypes = {\n  points: N.arrayOf(N.object),\n  symbol: N.func,\n  size: N.number.isRequired,\n  color: N.func.isRequired,\n  borderWidth: N.number.isRequired,\n  borderColor: N.func.isRequired,\n  enableLabel: N.bool.isRequired,\n  label: N.oneOfType([N.string, N.func]).isRequired,\n  labelYOffset: N.number\n};\nvar Be = e(ke),\n  Ee = function (e) {\n    var i = e.points,\n      o = e.width,\n      r = e.height,\n      a = e.margin,\n      s = e.setCurrent,\n      l = e.onMouseEnter,\n      u = e.onMouseMove,\n      d = e.onMouseLeave,\n      c = e.onClick,\n      h = e.onTouchStart,\n      f = e.onTouchMove,\n      p = e.onTouchEnd,\n      v = e.tooltip,\n      y = e.debug,\n      b = e.enableTouchCrosshair,\n      m = I(),\n      g = m.showTooltipAt,\n      x = m.hideTooltip,\n      R = n(function (e, i) {\n        g(t(v, {\n          point: e\n        }), [e.x + a.left, e.y + a.top], \"top\"), s(e), l && l(e, i);\n      }, [s, g, v, l, a]),\n      T = n(function (e, i) {\n        g(t(v, {\n          point: e\n        }), [e.x + a.left, e.y + a.top], \"top\"), s(e), u && u(e, i);\n      }, [g, v, a.left, a.top, s, u]),\n      q = n(function (e, i) {\n        x(), s(null), d && d(e, i);\n      }, [x, s, d]),\n      M = n(function (e, i) {\n        c && c(e, i);\n      }, [c]),\n      O = n(function (e, i) {\n        g(t(v, {\n          point: e\n        }), [e.x + a.left, e.y + a.top], \"top\"), s(e), h && h(e, i);\n      }, [a.left, a.top, h, s, g, v]),\n      S = n(function (e, i) {\n        g(t(v, {\n          point: e\n        }), [e.x + a.left, e.y + a.top], \"top\"), s(e), f && f(e, i);\n      }, [a.left, a.top, f, s, g, v]),\n      C = n(function (e, i) {\n        x(), s(null), p && p(e, i);\n      }, [p, x, s]);\n    return Q(_, {\n      nodes: i,\n      width: o,\n      height: r,\n      onMouseEnter: R,\n      onMouseMove: T,\n      onMouseLeave: q,\n      onClick: M,\n      onTouchStart: O,\n      onTouchMove: S,\n      onTouchEnd: C,\n      enableTouchCrosshair: b,\n      debug: y\n    });\n  };\nEe.propTypes = {\n  points: N.arrayOf(N.object).isRequired,\n  width: N.number.isRequired,\n  height: N.number.isRequired,\n  margin: N.object.isRequired,\n  setCurrent: N.func.isRequired,\n  onMouseEnter: N.func,\n  onMouseMove: N.func,\n  onMouseLeave: N.func,\n  onClick: N.func,\n  onTouchStart: N.func,\n  onTouchMove: N.func,\n  onTouchEnd: N.func,\n  tooltip: N.oneOfType([N.func, N.object]).isRequired,\n  debug: N.bool.isRequired\n};\nvar Le = e(Ee),\n  We = function (e) {\n    var i = e.data,\n      o = e.xScale,\n      n = void 0 === o ? {\n        type: \"point\"\n      } : o,\n      t = e.xFormat,\n      s = e.yScale,\n      l = void 0 === s ? {\n        type: \"linear\",\n        min: 0,\n        max: \"auto\"\n      } : s,\n      u = e.yFormat,\n      c = e.layers,\n      h = void 0 === c ? [\"grid\", \"markers\", \"axes\", \"areas\", \"crosshair\", \"lines\", \"points\", \"slices\", \"mesh\", \"legends\"] : c,\n      f = e.curve,\n      p = void 0 === f ? \"linear\" : f,\n      v = e.areaBaselineValue,\n      y = void 0 === v ? 0 : v,\n      b = e.colors,\n      m = void 0 === b ? {\n        scheme: \"nivo\"\n      } : b,\n      g = e.margin,\n      x = e.width,\n      R = e.height,\n      S = e.axisTop,\n      C = e.axisRight,\n      w = e.axisBottom,\n      k = void 0 === w ? {} : w,\n      B = e.axisLeft,\n      L = void 0 === B ? {} : B,\n      P = e.enableGridX,\n      j = void 0 === P || P,\n      F = e.enableGridY,\n      Y = void 0 === F || F,\n      D = e.gridXValues,\n      X = e.gridYValues,\n      A = e.lineWidth,\n      I = void 0 === A ? 2 : A,\n      H = e.enableArea,\n      J = void 0 !== H && H,\n      K = e.areaOpacity,\n      N = void 0 === K ? .2 : K,\n      U = e.areaBlendMode,\n      Z = void 0 === U ? \"normal\" : U,\n      $ = e.enablePoints,\n      _ = void 0 === $ || $,\n      ee = e.pointSymbol,\n      ie = e.pointSize,\n      oe = void 0 === ie ? 6 : ie,\n      ne = e.pointColor,\n      ae = void 0 === ne ? {\n        from: \"color\"\n      } : ne,\n      le = e.pointBorderWidth,\n      ue = void 0 === le ? 0 : le,\n      de = e.pointBorderColor,\n      ce = void 0 === de ? {\n        theme: \"background\"\n      } : de,\n      he = e.enablePointLabel,\n      fe = void 0 !== he && he,\n      pe = e.pointLabel,\n      ve = void 0 === pe ? \"yFormatted\" : pe,\n      ye = e.pointLabelYOffset,\n      me = e.defs,\n      ge = void 0 === me ? [] : me,\n      Re = e.fill,\n      Te = void 0 === Re ? [] : Re,\n      qe = e.markers,\n      Oe = e.legends,\n      Se = void 0 === Oe ? [] : Oe,\n      Ce = e.isInteractive,\n      ke = void 0 === Ce || Ce,\n      Ee = e.useMesh,\n      We = void 0 !== Ee && Ee,\n      Ge = e.debugMesh,\n      Pe = void 0 !== Ge && Ge,\n      je = e.onMouseEnter,\n      Fe = e.onMouseMove,\n      Ve = e.onMouseLeave,\n      Ye = e.onClick,\n      De = e.onTouchStart,\n      Xe = e.onTouchMove,\n      Ae = e.onTouchEnd,\n      Ie = e.tooltip,\n      ze = void 0 === Ie ? te : Ie,\n      He = e.enableSlices,\n      Je = void 0 !== He && He,\n      Ke = e.debugSlices,\n      Ne = void 0 !== Ke && Ke,\n      Qe = e.sliceTooltip,\n      Ue = void 0 === Qe ? se : Qe,\n      Ze = e.enableCrosshair,\n      $e = void 0 === Ze || Ze,\n      _e = e.crosshairType,\n      ei = void 0 === _e ? \"bottom-left\" : _e,\n      ii = e.enableTouchCrosshair,\n      oi = void 0 !== ii && ii,\n      ri = e.role,\n      ni = void 0 === ri ? \"img\" : ri,\n      ti = T(x, R, g),\n      ai = ti.margin,\n      si = ti.innerWidth,\n      li = ti.innerHeight,\n      ui = ti.outerWidth,\n      di = ti.outerHeight,\n      ci = be({\n        data: i,\n        xScale: n,\n        xFormat: t,\n        yScale: l,\n        yFormat: u,\n        width: si,\n        height: li,\n        colors: m,\n        curve: p,\n        areaBaselineValue: y,\n        pointColor: ae,\n        pointBorderColor: ce,\n        enableSlices: Je\n      }),\n      hi = ci.legendData,\n      fi = ci.toggleSerie,\n      pi = ci.lineGenerator,\n      vi = ci.areaGenerator,\n      yi = ci.series,\n      bi = ci.xScale,\n      mi = ci.yScale,\n      gi = ci.slices,\n      xi = ci.points,\n      Ri = d(),\n      Ti = E(ae, Ri),\n      qi = E(ce, Ri),\n      Mi = r(null),\n      Oi = Mi[0],\n      Si = Mi[1],\n      Ci = r(null),\n      wi = Ci[0],\n      ki = Ci[1],\n      Bi = {\n        grid: Q(W, {\n          theme: Ri,\n          width: si,\n          height: li,\n          xScale: j ? bi : null,\n          yScale: Y ? mi : null,\n          xValues: D,\n          yValues: X\n        }, \"grid\"),\n        markers: Q(q, {\n          markers: qe,\n          width: si,\n          height: li,\n          xScale: bi,\n          yScale: mi,\n          theme: Ri\n        }, \"markers\"),\n        axes: Q(G, {\n          xScale: bi,\n          yScale: mi,\n          width: si,\n          height: li,\n          theme: Ri,\n          top: S,\n          right: C,\n          bottom: k,\n          left: L\n        }, \"axes\"),\n        areas: null,\n        lines: Q(Me, {\n          lines: yi,\n          lineGenerator: pi,\n          lineWidth: I\n        }, \"lines\"),\n        slices: null,\n        points: null,\n        crosshair: null,\n        mesh: null,\n        legends: Se.map(function (e, i) {\n          return Q(V, re({}, e, {\n            containerWidth: si,\n            containerHeight: li,\n            data: e.data || hi,\n            theme: Ri,\n            toggleSerie: e.toggleSerie ? fi : void 0\n          }), \"legend.\" + i);\n        })\n      },\n      Ei = M(ge, yi, Te);\n    return J && (Bi.areas = Q(xe, {\n      areaGenerator: vi,\n      areaOpacity: N,\n      areaBlendMode: Z,\n      lines: yi\n    }, \"areas\")), ke && !1 !== Je && (Bi.slices = Q(we, {\n      slices: gi,\n      axis: Je,\n      debug: Ne,\n      height: li,\n      tooltip: Ue,\n      current: wi,\n      setCurrent: ki,\n      onMouseEnter: je,\n      onMouseMove: Fe,\n      onMouseLeave: Ve,\n      onClick: Ye,\n      onTouchStart: De,\n      onTouchMove: Xe,\n      onTouchEnd: Ae\n    }, \"slices\")), _ && (Bi.points = Q(Be, {\n      points: xi,\n      symbol: ee,\n      size: oe,\n      color: Ti,\n      borderWidth: ue,\n      borderColor: qi,\n      enableLabel: fe,\n      label: ve,\n      labelYOffset: ye\n    }, \"points\")), ke && $e && (null !== Oi && (Bi.crosshair = Q(z, {\n      width: si,\n      height: li,\n      x: Oi.x,\n      y: Oi.y,\n      type: ei\n    }, \"crosshair\")), null !== wi && (Bi.crosshair = Q(z, {\n      width: si,\n      height: li,\n      x: wi.x,\n      y: wi.y,\n      type: Je\n    }, \"crosshair\"))), ke && We && !1 === Je && (Bi.mesh = Q(Le, {\n      points: xi,\n      width: si,\n      height: li,\n      margin: ai,\n      current: Oi,\n      setCurrent: Si,\n      onMouseEnter: je,\n      onMouseMove: Fe,\n      onMouseLeave: Ve,\n      onClick: Ye,\n      onTouchStart: De,\n      onTouchMove: Xe,\n      onTouchEnd: Ae,\n      tooltip: ze,\n      enableTouchCrosshair: oi,\n      debug: Pe\n    }, \"mesh\")), Q(O, {\n      defs: Ei,\n      width: ui,\n      height: di,\n      margin: ai,\n      role: ni,\n      children: h.map(function (i, o) {\n        return \"function\" == typeof i ? Q(a, {\n          children: i(re({}, e, {\n            innerWidth: si,\n            innerHeight: li,\n            series: yi,\n            slices: gi,\n            points: xi,\n            xScale: bi,\n            yScale: mi,\n            lineGenerator: pi,\n            areaGenerator: vi,\n            currentPoint: Oi,\n            setCurrentPoint: Si,\n            currentSlice: wi,\n            setCurrentSlice: ki\n          }))\n        }, o) : Bi[i];\n      })\n    });\n  };\nWe.propTypes = ue;\nvar Ge = R(We),\n  Pe = function (e) {\n    return Q(S, {\n      children: function (i) {\n        var o = i.width,\n          r = i.height;\n        return Q(Ge, re({\n          width: o,\n          height: r\n        }, e));\n      }\n    });\n  },\n  je = function (e) {\n    var i = l(null),\n      o = e.width,\n      a = e.height,\n      s = e.margin,\n      c = e.pixelRatio,\n      h = void 0 === c ? \"undefined\" != typeof window && window.devicePixelRatio || 1 : c,\n      f = e.data,\n      p = e.xScale,\n      v = void 0 === p ? {\n        type: \"point\"\n      } : p,\n      y = e.xFormat,\n      b = e.yScale,\n      m = void 0 === b ? {\n        type: \"linear\",\n        min: 0,\n        max: \"auto\"\n      } : b,\n      g = e.yFormat,\n      x = e.curve,\n      R = void 0 === x ? \"linear\" : x,\n      q = e.layers,\n      M = void 0 === q ? [\"grid\", \"markers\", \"axes\", \"areas\", \"crosshair\", \"lines\", \"points\", \"slices\", \"mesh\", \"legends\"] : q,\n      O = e.colors,\n      S = void 0 === O ? {\n        scheme: \"nivo\"\n      } : O,\n      k = e.lineWidth,\n      B = void 0 === k ? 2 : k,\n      E = e.enableArea,\n      L = void 0 !== E && E,\n      W = e.areaBaselineValue,\n      G = void 0 === W ? 0 : W,\n      F = e.areaOpacity,\n      V = void 0 === F ? .2 : F,\n      D = e.enablePoints,\n      X = void 0 === D || D,\n      A = e.pointSize,\n      z = void 0 === A ? 6 : A,\n      H = e.pointColor,\n      J = void 0 === H ? {\n        from: \"color\"\n      } : H,\n      K = e.pointBorderWidth,\n      N = void 0 === K ? 0 : K,\n      U = e.pointBorderColor,\n      Z = void 0 === U ? {\n        theme: \"background\"\n      } : U,\n      $ = e.enableGridX,\n      _ = void 0 === $ || $,\n      ne = e.gridXValues,\n      ae = e.enableGridY,\n      se = void 0 === ae || ae,\n      le = e.gridYValues,\n      ue = e.axisTop,\n      de = e.axisRight,\n      ce = e.axisBottom,\n      he = void 0 === ce ? {} : ce,\n      fe = e.axisLeft,\n      pe = void 0 === fe ? {} : fe,\n      ve = e.legends,\n      ye = void 0 === ve ? [] : ve,\n      me = e.isInteractive,\n      ge = void 0 === me || me,\n      xe = e.debugMesh,\n      Re = void 0 !== xe && xe,\n      Te = e.onMouseLeave,\n      qe = e.onClick,\n      Me = e.tooltip,\n      Oe = void 0 === Me ? te : Me,\n      Se = e.canvasRef,\n      Ce = T(o, a, s),\n      we = Ce.margin,\n      ke = Ce.innerWidth,\n      Be = Ce.innerHeight,\n      Ee = Ce.outerWidth,\n      Le = Ce.outerHeight,\n      We = d(),\n      Ge = r(null),\n      Pe = Ge[0],\n      je = Ge[1],\n      Fe = be({\n        data: f,\n        xScale: v,\n        xFormat: y,\n        yScale: m,\n        yFormat: g,\n        width: ke,\n        height: Be,\n        colors: S,\n        curve: R,\n        areaBaselineValue: G,\n        pointColor: J,\n        pointBorderColor: Z\n      }),\n      Ve = Fe.lineGenerator,\n      Ye = Fe.areaGenerator,\n      De = Fe.series,\n      Xe = Fe.xScale,\n      Ae = Fe.yScale,\n      Ie = Fe.points,\n      ze = ee({\n        points: Ie,\n        width: ke,\n        height: Be,\n        debug: Re\n      }),\n      He = ze.delaunay,\n      Je = ze.voronoi;\n    u(function () {\n      Se && (Se.current = i.current), i.current.width = Ee * h, i.current.height = Le * h;\n      var e = i.current.getContext(\"2d\");\n      e.scale(h, h), e.fillStyle = We.background, e.fillRect(0, 0, Ee, Le), e.translate(we.left, we.top), M.forEach(function (i) {\n        if (\"function\" == typeof i && i({\n          ctx: e,\n          innerWidth: ke,\n          innerHeight: Be,\n          series: De,\n          points: Ie,\n          xScale: Xe,\n          yScale: Ae,\n          lineWidth: B,\n          lineGenerator: Ve,\n          areaGenerator: Ye,\n          currentPoint: Pe,\n          setCurrentPoint: je\n        }), \"grid\" === i && We.grid.line.strokeWidth > 0 && (e.lineWidth = We.grid.line.strokeWidth, e.strokeStyle = We.grid.line.stroke, _ && P(e, {\n          width: ke,\n          height: Be,\n          scale: Xe,\n          axis: \"x\",\n          values: ne\n        }), se && P(e, {\n          width: ke,\n          height: Be,\n          scale: Ae,\n          axis: \"y\",\n          values: le\n        })), \"axes\" === i && j(e, {\n          xScale: Xe,\n          yScale: Ae,\n          width: ke,\n          height: Be,\n          top: ue,\n          right: de,\n          bottom: he,\n          left: pe,\n          theme: We\n        }), \"areas\" === i && !0 === L && (e.save(), e.globalAlpha = V, Ye.context(e), De.forEach(function (i) {\n          e.fillStyle = i.color, e.beginPath(), Ye(i.data.map(function (e) {\n            return e.position;\n          })), e.fill();\n        }), e.restore()), \"lines\" === i && (Ve.context(e), De.forEach(function (i) {\n          e.strokeStyle = i.color, e.lineWidth = B, e.beginPath(), Ve(i.data.map(function (e) {\n            return e.position;\n          })), e.stroke();\n        })), \"points\" === i && !0 === X && z > 0 && Ie.forEach(function (i) {\n          e.fillStyle = i.color, e.beginPath(), e.arc(i.x, i.y, z / 2, 0, 2 * Math.PI), e.fill(), N > 0 && (e.strokeStyle = i.borderColor, e.lineWidth = N, e.stroke());\n        }), \"mesh\" === i && !0 === Re && (ie(e, Je), Pe && oe(e, Je, Pe.index)), \"legends\" === i) {\n          var o = De.map(function (e) {\n            return {\n              id: e.id,\n              label: e.id,\n              color: e.color\n            };\n          }).reverse();\n          ye.forEach(function (i) {\n            Y(e, re({}, i, {\n              data: i.data || o,\n              containerWidth: ke,\n              containerHeight: Be,\n              theme: We\n            }));\n          });\n        }\n      });\n    }, [i, Ee, Le, M, We, Ve, De, Xe, Ae, _, ne, se, le, ue, de, he, pe, ye, Ie, X, z, Pe]);\n    var Ke = n(function (e) {\n        var o = C(i.current, e),\n          r = o[0],\n          n = o[1];\n        if (!w(we.left, we.top, ke, Be, r, n)) return null;\n        var t = He.find(r - we.left, n - we.top);\n        return Ie[t];\n      }, [i, we, ke, Be, He]),\n      Ne = I(),\n      Qe = Ne.showTooltipFromEvent,\n      Ue = Ne.hideTooltip,\n      Ze = n(function (e) {\n        var i = Ke(e);\n        je(i), i ? Qe(t(Oe, {\n          point: i\n        }), e) : Ue();\n      }, [Ke, je, Qe, Ue, Oe]),\n      $e = n(function (e) {\n        Ue(), je(null), Pe && Te && Te(Pe, e);\n      }, [Ue, je, Te]),\n      _e = n(function (e) {\n        if (qe) {\n          var i = Ke(e);\n          i && qe(i, e);\n        }\n      }, [Ke, qe]);\n    return Q(\"canvas\", {\n      ref: i,\n      width: Ee * h,\n      height: Le * h,\n      style: {\n        width: Ee,\n        height: Le,\n        cursor: ge ? \"auto\" : \"normal\"\n      },\n      onMouseEnter: ge ? Ze : void 0,\n      onMouseMove: ge ? Ze : void 0,\n      onMouseLeave: ge ? $e : void 0,\n      onClick: ge ? _e : void 0\n    });\n  };\nje.propTypes = de;\nvar Fe = R(je),\n  Ve = s(function (e, i) {\n    return Q(Fe, re({}, e, {\n      canvasRef: i\n    }));\n  }),\n  Ye = s(function (e, i) {\n    return Q(S, {\n      children: function (o) {\n        var r = o.width,\n          n = o.height;\n        return Q(Ve, re({\n          width: r,\n          height: n\n        }, e, {\n          ref: i\n        }));\n      }\n    });\n  });\nexport { Ge as Line, Ve as LineCanvas, fe as LineCanvasDefaultProps, de as LineCanvasPropTypes, he as LineDefaultProps, ue as LinePropTypes, Pe as ResponsiveLine, Ye as ResponsiveLineCanvas, ve as useAreaGenerator, be as useLine, pe as useLineGenerator, ye as useSlices };","map":{"version":3,"mappings":"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","names":["LinePointTooltip","_ref","point","_jsx","BasicTooltip","id","_jsxs","children","data","xFormatted","yFormatted","enableChip","color","serieColor","propTypes","PropTypes","object","isRequired","memo","SliceTooltip","slice","axis","theme","useTheme","otherAxis","TableTooltip","rows","points","map","Chip","style","tooltip","chip","serieId","tableCellValue","oneOf","commonPropTypes","arrayOf","shape","oneOfType","string","number","x","instanceOf","Date","y","xScale","xFormat","func","yScale","yFormat","layers","curve","lineCurvePropType","axisTop","axisPropType","axisRight","axisBottom","axisLeft","enableGridX","bool","enableGridY","gridXValues","gridYValues","enablePoints","pointSymbol","pointSize","pointColor","any","pointBorderWidth","pointBorderColor","enablePointLabel","pointLabel","markers","value","colors","ordinalColorsPropType","enableArea","areaOpacity","areaBlendMode","blendModePropType","areaBaselineValue","lineWidth","legends","LegendPropShape","isInteractive","debugMesh","enableSlices","debugSlices","sliceTooltip","enableCrosshair","crosshairType","LinePropTypes","_extends","role","useMesh","enableTouchCrosshair","motionPropTypes","defsPropTypes","LineCanvasPropTypes","pixelRatio","commonDefaultProps","type","min","max","from","scheme","PointTooltip","LineDefaultProps","animate","motionConfig","defs","fill","LineCanvasDefaultProps","window","devicePixelRatio","useLineGenerator","useMemo","line","defined","d","curveFromProp","useAreaGenerator","_ref2","area","y1","y0","useSlices","_ref4","componentId","width","height","Map","forEach","has","get","push","set","Array","entries","sort","a","b","i","slices","x0","sliceWidth","_ref5","slicePoints","prevSlice","nextSlice","reverse","sliceHeight","_ref6","useLine","_ref7","_ref7$xScale","xScaleSpec","_ref7$yScale","yScaleSpec","_ref7$colors","_ref7$curve","_ref7$areaBaselineVal","_ref7$pointColor","_ref7$pointBorderColo","_ref7$enableSlices","enableSlicesTooltip","useId","formatX","useValueFormatter","formatY","getColor","useOrdinalColorScale","getPointColor","useInheritedColor","getPointBorderColor","_useState","useState","hiddenIds","setHiddenIds","_useMemo","computeXYScalesForSeries","filter","indexOf","item","rawSeries","series","_useMemo2","dataWithColor","label","find","serie","datum","Boolean","legendData","hidden","toggleSerie","useCallback","state","concat","_ref3","reduce","acc","position","index","length","borderColor","usePoints","lineGenerator","areaGenerator","AreaPath","path","_useMotionConfig","useMotionConfig","springConfig","config","animatedPath","useAnimatedPath","animatedProps","useSpring","immediate","animated","fillOpacity","strokeWidth","mixBlendMode","Areas","computedLines","lines","LinesItem","thickness","stroke","Lines","SlicesItem","debug","isCurrent","setCurrent","onMouseEnter","onMouseMove","onMouseLeave","onClick","onTouchStart","onTouchMove","onTouchEnd","_useTooltip","useTooltip","showTooltipFromEvent","hideTooltip","handleMouseEnter","createElement","event","handleMouseMove","handleMouseLeave","handleClick","handeOnTouchStart","handeOnTouchMove","touchPoint","touches","touchingElement","document","elementFromPoint","clientX","clientY","touchingSliceId","getAttribute","handleOnTouchEnd","strokeOpacity","Slices","current","Points","symbol","size","borderWidth","enableLabel","labelYOffset","getLabel","getLabelGenerator","mappedPoints","DotsItem","Mesh","margin","showTooltipAt","left","top","handleTouchStart","handleTouchMove","handleTouchEnd","BaseMesh","nodes","Line","props","_props$xScale","_props$yScale","_props$layers","_props$curve","_props$areaBaselineVa","_props$colors","partialMargin","_props$axisBottom","_props$axisLeft","_props$enableGridX","_props$enableGridY","_props$lineWidth","_props$enableArea","_props$areaOpacity","_props$areaBlendMode","_props$enablePoints","_props$pointSize","_props$pointColor","_props$pointBorderWid","_props$pointBorderCol","_props$enablePointLab","_props$pointLabel","pointLabelYOffset","_props$defs","_props$fill","_props$legends","_props$isInteractive","_props$useMesh","_props$debugMesh","_props$tooltip","_props$enableSlices","_props$debugSlices","_props$sliceTooltip","_props$enableCrosshai","_props$crosshairType","_props$enableTouchCro","_props$role","_useDimensions","useDimensions","innerWidth","innerHeight","outerWidth","outerHeight","_useLine","currentPoint","setCurrentPoint","_useState2","currentSlice","setCurrentSlice","layerById","grid","Grid","xValues","yValues","CartesianMarkers","axes","Axes","right","bottom","areas","crosshair","mesh","legend","BoxLegendSvg","containerWidth","containerHeight","undefined","boundDefs","bindDefs","Crosshair","SvgWrapper","layer","Fragment","withContainer","ResponsiveLine","ResponsiveWrapper","LineCanvas","canvasEl","useRef","_props$pixelRatio","canvasRef","_useVoronoiMesh","useVoronoiMesh","delaunay","voronoi","useEffect","ctx","getContext","scale","fillStyle","background","fillRect","translate","strokeStyle","renderGridLinesToCanvas","values","renderAxesToCanvas","save","globalAlpha","context","beginPath","restore","arc","Math","PI","renderVoronoiToCanvas","renderVoronoiCellToCanvas","renderLegendToCanvas","getPointFromMouseEvent","getRelativeCursor","_getRelativeCursor","isCursorInRect","pointIndex","handleMouseHover","ref","cursor","LineCanvasWithContainer","LineCanvas$1","forwardRef"],"sources":["/Users/parijatchatterjee/Desktop/react-admin-dashboard/node_modules/@nivo/line/src/PointTooltip.js","/Users/parijatchatterjee/Desktop/react-admin-dashboard/node_modules/@nivo/line/src/SliceTooltip.js","/Users/parijatchatterjee/Desktop/react-admin-dashboard/node_modules/@nivo/line/src/props.js","/Users/parijatchatterjee/Desktop/react-admin-dashboard/node_modules/@nivo/line/src/hooks.js","/Users/parijatchatterjee/Desktop/react-admin-dashboard/node_modules/@nivo/line/src/Areas.js","/Users/parijatchatterjee/Desktop/react-admin-dashboard/node_modules/@nivo/line/src/LinesItem.js","/Users/parijatchatterjee/Desktop/react-admin-dashboard/node_modules/@nivo/line/src/Lines.js","/Users/parijatchatterjee/Desktop/react-admin-dashboard/node_modules/@nivo/line/src/SlicesItem.js","/Users/parijatchatterjee/Desktop/react-admin-dashboard/node_modules/@nivo/line/src/Slices.js","/Users/parijatchatterjee/Desktop/react-admin-dashboard/node_modules/@nivo/line/src/Points.js","/Users/parijatchatterjee/Desktop/react-admin-dashboard/node_modules/@nivo/line/src/Mesh.js","/Users/parijatchatterjee/Desktop/react-admin-dashboard/node_modules/@nivo/line/src/Line.js","/Users/parijatchatterjee/Desktop/react-admin-dashboard/node_modules/@nivo/line/src/ResponsiveLine.js","/Users/parijatchatterjee/Desktop/react-admin-dashboard/node_modules/@nivo/line/src/LineCanvas.js","/Users/parijatchatterjee/Desktop/react-admin-dashboard/node_modules/@nivo/line/src/ResponsiveLineCanvas.js"],"sourcesContent":["/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { memo } from 'react'\nimport PropTypes from 'prop-types'\nimport { BasicTooltip } from '@nivo/tooltip'\n\nconst LinePointTooltip = ({ point }) => {\n    return (\n        <BasicTooltip\n            id={\n                <span>\n                    x: <strong>{point.data.xFormatted}</strong>, y:{' '}\n                    <strong>{point.data.yFormatted}</strong>\n                </span>\n            }\n            enableChip={true}\n            color={point.serieColor}\n        />\n    )\n}\n\nLinePointTooltip.propTypes = {\n    point: PropTypes.object.isRequired,\n}\n\nexport default memo(LinePointTooltip)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { memo } from 'react'\nimport PropTypes from 'prop-types'\nimport { useTheme } from '@nivo/core'\nimport { Chip, TableTooltip } from '@nivo/tooltip'\n\nconst SliceTooltip = ({ slice, axis }) => {\n    const theme = useTheme()\n    const otherAxis = axis === 'x' ? 'y' : 'x'\n\n    return (\n        <TableTooltip\n            rows={slice.points.map(point => [\n                <Chip key=\"chip\" color={point.serieColor} style={theme.tooltip.chip} />,\n                point.serieId,\n                <span key=\"value\" style={theme.tooltip.tableCellValue}>\n                    {point.data[`${otherAxis}Formatted`]}\n                </span>,\n            ])}\n        />\n    )\n}\n\nSliceTooltip.propTypes = {\n    slice: PropTypes.object.isRequired,\n    axis: PropTypes.oneOf(['x', 'y']).isRequired,\n}\n\nexport default memo(SliceTooltip)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport PropTypes from 'prop-types'\nimport { lineCurvePropType, blendModePropType, motionPropTypes, defsPropTypes } from '@nivo/core'\nimport { ordinalColorsPropType } from '@nivo/colors'\nimport { axisPropType } from '@nivo/axes'\nimport { LegendPropShape } from '@nivo/legends'\nimport PointTooltip from './PointTooltip'\nimport SliceTooltip from './SliceTooltip'\n\nconst commonPropTypes = {\n    data: PropTypes.arrayOf(\n        PropTypes.shape({\n            id: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,\n            data: PropTypes.arrayOf(\n                PropTypes.shape({\n                    x: PropTypes.oneOfType([\n                        PropTypes.number,\n                        PropTypes.string,\n                        PropTypes.instanceOf(Date),\n                    ]),\n                    y: PropTypes.oneOfType([\n                        PropTypes.number,\n                        PropTypes.string,\n                        PropTypes.instanceOf(Date),\n                    ]),\n                })\n            ).isRequired,\n        })\n    ).isRequired,\n\n    xScale: PropTypes.object.isRequired,\n    xFormat: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n    yScale: PropTypes.object.isRequired,\n    yFormat: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n\n    layers: PropTypes.arrayOf(\n        PropTypes.oneOfType([\n            PropTypes.oneOf([\n                'grid',\n                'markers',\n                'axes',\n                'areas',\n                'crosshair',\n                'lines',\n                'slices',\n                'points',\n                'mesh',\n                'legends',\n            ]),\n            PropTypes.func,\n        ])\n    ).isRequired,\n\n    curve: lineCurvePropType.isRequired,\n\n    axisTop: axisPropType,\n    axisRight: axisPropType,\n    axisBottom: axisPropType,\n    axisLeft: axisPropType,\n\n    enableGridX: PropTypes.bool.isRequired,\n    enableGridY: PropTypes.bool.isRequired,\n    gridXValues: PropTypes.oneOfType([\n        PropTypes.number,\n        PropTypes.arrayOf(\n            PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.instanceOf(Date)])\n        ),\n    ]),\n    gridYValues: PropTypes.oneOfType([\n        PropTypes.number,\n        PropTypes.arrayOf(\n            PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.instanceOf(Date)])\n        ),\n    ]),\n\n    enablePoints: PropTypes.bool.isRequired,\n    pointSymbol: PropTypes.func,\n    pointSize: PropTypes.number.isRequired,\n    pointColor: PropTypes.any.isRequired,\n    pointBorderWidth: PropTypes.number.isRequired,\n    pointBorderColor: PropTypes.any.isRequired,\n    enablePointLabel: PropTypes.bool.isRequired,\n    pointLabel: PropTypes.oneOfType([PropTypes.string, PropTypes.func]).isRequired,\n\n    markers: PropTypes.arrayOf(\n        PropTypes.shape({\n            axis: PropTypes.oneOf(['x', 'y']).isRequired,\n            value: PropTypes.oneOfType([\n                PropTypes.number,\n                PropTypes.string,\n                PropTypes.instanceOf(Date),\n            ]).isRequired,\n            style: PropTypes.object,\n        })\n    ),\n\n    colors: ordinalColorsPropType.isRequired,\n\n    enableArea: PropTypes.bool.isRequired,\n    areaOpacity: PropTypes.number.isRequired,\n    areaBlendMode: blendModePropType.isRequired,\n    areaBaselineValue: PropTypes.oneOfType([\n        PropTypes.number,\n        PropTypes.string,\n        PropTypes.instanceOf(Date),\n    ]).isRequired,\n    lineWidth: PropTypes.number.isRequired,\n\n    legends: PropTypes.arrayOf(PropTypes.shape(LegendPropShape)).isRequired,\n\n    isInteractive: PropTypes.bool.isRequired,\n    debugMesh: PropTypes.bool.isRequired,\n\n    tooltip: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,\n\n    enableSlices: PropTypes.oneOf(['x', 'y', false]).isRequired,\n    debugSlices: PropTypes.bool.isRequired,\n    sliceTooltip: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,\n\n    enableCrosshair: PropTypes.bool.isRequired,\n    crosshairType: PropTypes.string.isRequired,\n}\n\nexport const LinePropTypes = {\n    ...commonPropTypes,\n    enablePointLabel: PropTypes.bool.isRequired,\n    role: PropTypes.string.isRequired,\n    useMesh: PropTypes.bool.isRequired,\n    enableTouchCrosshair: PropTypes.bool,\n    ...motionPropTypes,\n    ...defsPropTypes,\n}\n\nexport const LineCanvasPropTypes = {\n    pixelRatio: PropTypes.number.isRequired,\n    ...commonPropTypes,\n}\n\nconst commonDefaultProps = {\n    curve: 'linear',\n\n    xScale: {\n        type: 'point',\n    },\n    yScale: {\n        type: 'linear',\n        min: 0,\n        max: 'auto',\n    },\n\n    layers: [\n        'grid',\n        'markers',\n        'axes',\n        'areas',\n        'crosshair',\n        'lines',\n        'points',\n        'slices',\n        'mesh',\n        'legends',\n    ],\n    axisBottom: {},\n    axisLeft: {},\n    enableGridX: true,\n    enableGridY: true,\n\n    enablePoints: true,\n    pointSize: 6,\n    pointColor: { from: 'color' },\n    pointBorderWidth: 0,\n    pointBorderColor: { theme: 'background' },\n    enablePointLabel: false,\n    pointLabel: 'yFormatted',\n\n    colors: { scheme: 'nivo' },\n    enableArea: false,\n    areaBaselineValue: 0,\n    areaOpacity: 0.2,\n    areaBlendMode: 'normal',\n    lineWidth: 2,\n\n    legends: [],\n\n    isInteractive: true,\n    tooltip: PointTooltip,\n    enableSlices: false,\n    debugSlices: false,\n    sliceTooltip: SliceTooltip,\n    debugMesh: false,\n    enableCrosshair: true,\n    crosshairType: 'bottom-left',\n}\n\nexport const LineDefaultProps = {\n    ...commonDefaultProps,\n    enablePointLabel: false,\n    useMesh: false,\n    enableTouchCrosshair: false,\n    animate: true,\n    motionConfig: 'gentle',\n    defs: [],\n    fill: [],\n    role: 'img',\n}\n\nexport const LineCanvasDefaultProps = {\n    ...commonDefaultProps,\n    pixelRatio: typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1,\n}\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { useCallback, useMemo, useState, useId } from 'react'\nimport { area, line } from 'd3-shape'\nimport { curveFromProp, useTheme, useValueFormatter } from '@nivo/core'\nimport { useOrdinalColorScale, useInheritedColor } from '@nivo/colors'\nimport { computeXYScalesForSeries } from '@nivo/scales'\nimport { LineDefaultProps } from './props'\n\nexport const useLineGenerator = ({ curve }) => {\n    return useMemo(\n        () =>\n            line()\n                .defined(d => d.x !== null && d.y !== null)\n                .x(d => d.x)\n                .y(d => d.y)\n                .curve(curveFromProp(curve)),\n        [curve]\n    )\n}\n\nexport const useAreaGenerator = ({ curve, yScale, areaBaselineValue }) => {\n    return useMemo(() => {\n        return area()\n            .defined(d => d.x !== null && d.y !== null)\n            .x(d => d.x)\n            .y1(d => d.y)\n            .curve(curveFromProp(curve))\n            .y0(yScale(areaBaselineValue))\n    }, [curve, yScale, areaBaselineValue])\n}\n\nconst usePoints = ({ series, getPointColor, getPointBorderColor, formatX, formatY }) => {\n    return useMemo(() => {\n        return series.reduce((acc, serie) => {\n            return [\n                ...acc,\n                ...serie.data\n                    .filter(datum => datum.position.x !== null && datum.position.y !== null)\n                    .map((datum, i) => {\n                        const point = {\n                            id: `${serie.id}.${i}`,\n                            index: acc.length + i,\n                            serieId: serie.id,\n                            serieColor: serie.color,\n                            x: datum.position.x,\n                            y: datum.position.y,\n                        }\n                        point.color = getPointColor(serie)\n                        point.borderColor = getPointBorderColor(point)\n                        point.data = {\n                            ...datum.data,\n                            xFormatted: formatX(datum.data.x),\n                            yFormatted: formatY(datum.data.y),\n                        }\n\n                        return point\n                    }),\n            ]\n        }, [])\n    }, [series, getPointColor, getPointBorderColor, formatX, formatY])\n}\n\nexport const useSlices = ({ componentId, enableSlices, points, width, height }) => {\n    return useMemo(() => {\n        if (enableSlices === false) return []\n\n        if (enableSlices === 'x') {\n            const map = new Map()\n            points.forEach(point => {\n                if (point.data.x === null || point.data.y === null) return\n                if (!map.has(point.x)) map.set(point.x, [point])\n                else map.get(point.x).push(point)\n            })\n            return Array.from(map.entries())\n                .sort((a, b) => a[0] - b[0])\n                .map(([x, slicePoints], i, slices) => {\n                    const prevSlice = slices[i - 1]\n                    const nextSlice = slices[i + 1]\n\n                    let x0\n                    if (!prevSlice) x0 = x\n                    else x0 = x - (x - prevSlice[0]) / 2\n\n                    let sliceWidth\n                    if (!nextSlice) sliceWidth = width - x0\n                    else sliceWidth = x - x0 + (nextSlice[0] - x) / 2\n\n                    return {\n                        id: `slice${componentId}${x}`,\n                        x0,\n                        x,\n                        y0: 0,\n                        y: 0,\n                        width: sliceWidth,\n                        height,\n                        points: slicePoints.reverse(),\n                    }\n                })\n        } else if (enableSlices === 'y') {\n            const map = new Map()\n            points.forEach(point => {\n                if (point.data.x === null || point.data.y === null) return\n                if (!map.has(point.y)) map.set(point.y, [point])\n                else map.get(point.y).push(point)\n            })\n            return Array.from(map.entries())\n                .sort((a, b) => a[0] - b[0])\n                .map(([y, slicePoints], i, slices) => {\n                    const prevSlice = slices[i - 1]\n                    const nextSlice = slices[i + 1]\n\n                    let y0\n                    if (!prevSlice) y0 = y\n                    else y0 = y - (y - prevSlice[0]) / 2\n\n                    let sliceHeight\n                    if (!nextSlice) sliceHeight = height - y0\n                    else sliceHeight = y - y0 + (nextSlice[0] - y) / 2\n\n                    return {\n                        id: y,\n                        x0: 0,\n                        x: 0,\n                        y0,\n                        y,\n                        width,\n                        height: sliceHeight,\n                        points: slicePoints.reverse(),\n                    }\n                })\n        }\n    }, [componentId, enableSlices, height, points, width])\n}\n\nexport const useLine = ({\n    data,\n    xScale: xScaleSpec = LineDefaultProps.xScale,\n    xFormat,\n    yScale: yScaleSpec = LineDefaultProps.yScale,\n    yFormat,\n    width,\n    height,\n    colors = LineDefaultProps.colors,\n    curve = LineDefaultProps.curve,\n    areaBaselineValue = LineDefaultProps.areaBaselineValue,\n    pointColor = LineDefaultProps.pointColor,\n    pointBorderColor = LineDefaultProps.pointBorderColor,\n    enableSlices = LineDefaultProps.enableSlicesTooltip,\n}) => {\n    const componentId = useId()\n    const formatX = useValueFormatter(xFormat)\n    const formatY = useValueFormatter(yFormat)\n    const getColor = useOrdinalColorScale(colors, 'id')\n    const theme = useTheme()\n    const getPointColor = useInheritedColor(pointColor, theme)\n    const getPointBorderColor = useInheritedColor(pointBorderColor, theme)\n    const [hiddenIds, setHiddenIds] = useState([])\n\n    const {\n        xScale,\n        yScale,\n        series: rawSeries,\n    } = useMemo(\n        () =>\n            computeXYScalesForSeries(\n                data.filter(item => hiddenIds.indexOf(item.id) === -1),\n                xScaleSpec,\n                yScaleSpec,\n                width,\n                height\n            ),\n        [data, hiddenIds, xScaleSpec, yScaleSpec, width, height]\n    )\n\n    const { legendData, series } = useMemo(() => {\n        const dataWithColor = data.map(line => ({\n            id: line.id,\n            label: line.id,\n            color: getColor(line),\n        }))\n        const series = dataWithColor\n            .map(datum => ({\n                ...rawSeries.find(serie => serie.id === datum.id),\n                color: datum.color,\n            }))\n            .filter(item => Boolean(item.id))\n        const legendData = dataWithColor\n            .map(item => ({ ...item, hidden: !series.find(serie => serie.id === item.id) }))\n            .reverse()\n\n        return { legendData, series }\n    }, [data, rawSeries, getColor])\n\n    const toggleSerie = useCallback(id => {\n        setHiddenIds(state =>\n            state.indexOf(id) > -1 ? state.filter(item => item !== id) : [...state, id]\n        )\n    }, [])\n\n    const points = usePoints({\n        series,\n        getPointColor,\n        getPointBorderColor,\n        formatX,\n        formatY,\n    })\n\n    const slices = useSlices({\n        componentId,\n        enableSlices,\n        points,\n        width,\n        height,\n    })\n\n    const lineGenerator = useLineGenerator({ curve })\n    const areaGenerator = useAreaGenerator({\n        curve,\n        yScale,\n        areaBaselineValue,\n    })\n\n    return {\n        legendData,\n        toggleSerie,\n        lineGenerator,\n        areaGenerator,\n        getColor,\n        series,\n        xScale,\n        yScale,\n        slices,\n        points,\n    }\n}\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { memo } from 'react'\nimport PropTypes from 'prop-types'\nimport { useSpring, animated } from '@react-spring/web'\nimport { useAnimatedPath, useMotionConfig, blendModePropType } from '@nivo/core'\n\nconst AreaPath = ({ areaBlendMode, areaOpacity, color, fill, path }) => {\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedPath = useAnimatedPath(path)\n    const animatedProps = useSpring({\n        color,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <animated.path\n            d={animatedPath}\n            fill={fill ? fill : animatedProps.color}\n            fillOpacity={areaOpacity}\n            strokeWidth={0}\n            style={{\n                mixBlendMode: areaBlendMode,\n            }}\n        />\n    )\n}\n\nAreaPath.propTypes = {\n    areaBlendMode: blendModePropType.isRequired,\n    areaOpacity: PropTypes.number.isRequired,\n    color: PropTypes.string,\n    fill: PropTypes.string,\n    path: PropTypes.string.isRequired,\n}\n\nconst Areas = ({ areaGenerator, areaOpacity, areaBlendMode, lines }) => {\n    const computedLines = lines.slice(0).reverse()\n\n    return (\n        <g>\n            {computedLines.map(line => (\n                <AreaPath\n                    key={line.id}\n                    path={areaGenerator(line.data.map(d => d.position))}\n                    {...{ areaOpacity, areaBlendMode, ...line }}\n                />\n            ))}\n        </g>\n    )\n}\n\nAreas.propTypes = {\n    areaGenerator: PropTypes.func.isRequired,\n    areaOpacity: PropTypes.number.isRequired,\n    areaBlendMode: blendModePropType.isRequired,\n    lines: PropTypes.arrayOf(PropTypes.object).isRequired,\n}\n\nexport default memo(Areas)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { memo, useMemo } from 'react'\nimport PropTypes from 'prop-types'\nimport { animated } from '@react-spring/web'\nimport { useAnimatedPath } from '@nivo/core'\n\nconst LinesItem = ({ lineGenerator, points, color, thickness }) => {\n    const path = useMemo(() => lineGenerator(points), [lineGenerator, points])\n    const animatedPath = useAnimatedPath(path)\n\n    return <animated.path d={animatedPath} fill=\"none\" strokeWidth={thickness} stroke={color} />\n}\n\nLinesItem.propTypes = {\n    points: PropTypes.arrayOf(\n        PropTypes.shape({\n            x: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n            y: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n        })\n    ),\n    lineGenerator: PropTypes.func.isRequired,\n    color: PropTypes.string.isRequired,\n    thickness: PropTypes.number.isRequired,\n}\n\nexport default memo(LinesItem)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { memo } from 'react'\nimport PropTypes from 'prop-types'\nimport LinesItem from './LinesItem'\n\nconst Lines = ({ lines, lineGenerator, lineWidth }) => {\n    return lines\n        .slice(0)\n        .reverse()\n        .map(({ id, data, color }) => (\n            <LinesItem\n                key={id}\n                id={id}\n                points={data.map(d => d.position)}\n                lineGenerator={lineGenerator}\n                color={color}\n                thickness={lineWidth}\n            />\n        ))\n}\n\nLines.propTypes = {\n    lines: PropTypes.arrayOf(\n        PropTypes.shape({\n            id: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,\n            color: PropTypes.string.isRequired,\n            data: PropTypes.arrayOf(\n                PropTypes.shape({\n                    data: PropTypes.shape({\n                        x: PropTypes.oneOfType([\n                            PropTypes.string,\n                            PropTypes.number,\n                            PropTypes.instanceOf(Date),\n                        ]),\n                        y: PropTypes.oneOfType([\n                            PropTypes.string,\n                            PropTypes.number,\n                            PropTypes.instanceOf(Date),\n                        ]),\n                    }).isRequired,\n                    position: PropTypes.shape({\n                        x: PropTypes.number,\n                        y: PropTypes.number,\n                    }).isRequired,\n                })\n            ).isRequired,\n        })\n    ).isRequired,\n    lineWidth: PropTypes.number.isRequired,\n    lineGenerator: PropTypes.func.isRequired,\n}\n\nexport default memo(Lines)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { createElement, memo, useCallback } from 'react'\nimport PropTypes from 'prop-types'\nimport { useTooltip } from '@nivo/tooltip'\n\nconst SlicesItem = ({\n    slice,\n    slices,\n    axis,\n    debug,\n    tooltip,\n    isCurrent,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n}) => {\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const handleMouseEnter = useCallback(\n        event => {\n            showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n            setCurrent(slice)\n            onMouseEnter && onMouseEnter(slice, event)\n        },\n        [showTooltipFromEvent, tooltip, slice, axis, setCurrent, onMouseEnter]\n    )\n\n    const handleMouseMove = useCallback(\n        event => {\n            showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n            onMouseMove && onMouseMove(slice, event)\n        },\n        [showTooltipFromEvent, tooltip, slice, axis, onMouseMove]\n    )\n\n    const handleMouseLeave = useCallback(\n        event => {\n            hideTooltip()\n            setCurrent(null)\n            onMouseLeave && onMouseLeave(slice, event)\n        },\n        [hideTooltip, setCurrent, onMouseLeave, slice]\n    )\n\n    const handleClick = useCallback(\n        event => {\n            onClick && onClick(slice, event)\n        },\n        [slice, onClick]\n    )\n\n    const handeOnTouchStart = useCallback(\n        event => {\n            showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n            setCurrent(slice)\n            onTouchStart && onTouchStart(slice, event)\n        },\n        [axis, onTouchStart, setCurrent, showTooltipFromEvent, slice, tooltip]\n    )\n\n    const handeOnTouchMove = useCallback(\n        event => {\n            // This event will be locked to the element that was touched originally\n            // We find the element that is currently being \"hovered over\" by getting the element at the touch point\n            const touchPoint = event.touches[0]\n            const touchingElement = document.elementFromPoint(\n                touchPoint.clientX,\n                touchPoint.clientY\n            )\n            // Is this a nivo ref?\n            const touchingSliceId = touchingElement?.getAttribute('data-ref')\n            if (touchingSliceId) {\n                // Is this a slice for this graph?\n                const slice = slices.find(slice => slice.id === touchingSliceId)\n                if (slice) {\n                    showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n                    setCurrent(slice)\n                }\n            }\n\n            // Note here, this will pass the original slice, not the one we found\n            // But this can be found with document.elementFromPoint()\n            onTouchMove && onTouchMove(slice, event)\n        },\n        [axis, onTouchMove, setCurrent, showTooltipFromEvent, slice, slices, tooltip]\n    )\n\n    const handleOnTouchEnd = useCallback(\n        event => {\n            hideTooltip()\n            setCurrent(null)\n            onTouchEnd && onTouchEnd(slice, event)\n        },\n        [hideTooltip, setCurrent, onTouchEnd, slice]\n    )\n\n    return (\n        <rect\n            x={slice.x0}\n            y={slice.y0}\n            width={slice.width}\n            height={slice.height}\n            stroke=\"red\"\n            strokeWidth={debug ? 1 : 0}\n            strokeOpacity={0.75}\n            fill=\"red\"\n            fillOpacity={isCurrent && debug ? 0.35 : 0}\n            onMouseEnter={handleMouseEnter}\n            onMouseMove={handleMouseMove}\n            onMouseLeave={handleMouseLeave}\n            onClick={handleClick}\n            onTouchStart={handeOnTouchStart}\n            onTouchMove={handeOnTouchMove}\n            onTouchEnd={handleOnTouchEnd}\n            data-ref={slice.id}\n        />\n    )\n}\n\nSlicesItem.propTypes = {\n    slice: PropTypes.object.isRequired,\n    slices: PropTypes.arrayOf(PropTypes.object).isRequired,\n    axis: PropTypes.oneOf(['x', 'y']).isRequired,\n    debug: PropTypes.bool.isRequired,\n    height: PropTypes.number.isRequired,\n    tooltip: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),\n    isCurrent: PropTypes.bool.isRequired,\n    setCurrent: PropTypes.func.isRequired,\n    onMouseEnter: PropTypes.func,\n    onMouseMove: PropTypes.func,\n    onMouseLeave: PropTypes.func,\n    onClick: PropTypes.func,\n}\n\nexport default memo(SlicesItem)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { memo } from 'react'\nimport PropTypes from 'prop-types'\nimport SlicesItem from './SlicesItem'\n\nconst Slices = ({\n    slices,\n    axis,\n    debug,\n    height,\n    tooltip,\n    current,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n}) => {\n    return slices.map(slice => (\n        <SlicesItem\n            key={slice.id}\n            slice={slice}\n            slices={slices}\n            axis={axis}\n            debug={debug}\n            height={height}\n            tooltip={tooltip}\n            setCurrent={setCurrent}\n            isCurrent={current !== null && current.id === slice.id}\n            onMouseEnter={onMouseEnter}\n            onMouseMove={onMouseMove}\n            onMouseLeave={onMouseLeave}\n            onClick={onClick}\n            onTouchStart={onTouchStart}\n            onTouchMove={onTouchMove}\n            onTouchEnd={onTouchEnd}\n        />\n    ))\n}\n\nSlices.propTypes = {\n    slices: PropTypes.arrayOf(\n        PropTypes.shape({\n            id: PropTypes.oneOfType([\n                PropTypes.number,\n                PropTypes.string,\n                PropTypes.instanceOf(Date),\n            ]).isRequired,\n            x: PropTypes.number.isRequired,\n            y: PropTypes.number.isRequired,\n            points: PropTypes.arrayOf(PropTypes.object).isRequired,\n        })\n    ).isRequired,\n    axis: PropTypes.oneOf(['x', 'y']).isRequired,\n    debug: PropTypes.bool.isRequired,\n    height: PropTypes.number.isRequired,\n    tooltip: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,\n    current: PropTypes.object,\n    setCurrent: PropTypes.func.isRequired,\n    onMouseEnter: PropTypes.func,\n    onMouseMove: PropTypes.func,\n    onMouseLeave: PropTypes.func,\n    onClick: PropTypes.func,\n    onTouchStart: PropTypes.func,\n    onTouchMove: PropTypes.func,\n    onTouchEnd: PropTypes.func,\n}\n\nexport default memo(Slices)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { memo } from 'react'\nimport PropTypes from 'prop-types'\nimport { getLabelGenerator, DotsItem, useTheme } from '@nivo/core'\n\nconst Points = ({ points, symbol, size, borderWidth, enableLabel, label, labelYOffset }) => {\n    const theme = useTheme()\n    const getLabel = getLabelGenerator(label)\n\n    /**\n     * We reverse the `points` array so that points from the lower lines in stacked lines\n     * graph are drawn on top. See https://github.com/plouc/nivo/issues/1051.\n     */\n    const mappedPoints = points\n        .slice(0)\n        .reverse()\n        .map(point => {\n            const mappedPoint = {\n                id: point.id,\n                x: point.x,\n                y: point.y,\n                datum: point.data,\n                fill: point.color,\n                stroke: point.borderColor,\n                label: enableLabel ? getLabel(point.data) : null,\n            }\n\n            return mappedPoint\n        })\n\n    return (\n        <g>\n            {mappedPoints.map(point => (\n                <DotsItem\n                    key={point.id}\n                    x={point.x}\n                    y={point.y}\n                    datum={point.datum}\n                    symbol={symbol}\n                    size={size}\n                    color={point.fill}\n                    borderWidth={borderWidth}\n                    borderColor={point.stroke}\n                    label={point.label}\n                    labelYOffset={labelYOffset}\n                    theme={theme}\n                />\n            ))}\n        </g>\n    )\n}\n\nPoints.propTypes = {\n    points: PropTypes.arrayOf(PropTypes.object),\n    symbol: PropTypes.func,\n    size: PropTypes.number.isRequired,\n    color: PropTypes.func.isRequired,\n    borderWidth: PropTypes.number.isRequired,\n    borderColor: PropTypes.func.isRequired,\n    enableLabel: PropTypes.bool.isRequired,\n    label: PropTypes.oneOfType([PropTypes.string, PropTypes.func]).isRequired,\n    labelYOffset: PropTypes.number,\n}\n\nexport default memo(Points)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { createElement, memo, useCallback } from 'react'\nimport PropTypes from 'prop-types'\nimport { useTooltip } from '@nivo/tooltip'\nimport { Mesh as BaseMesh } from '@nivo/voronoi'\n\nconst Mesh = ({\n    points,\n    width,\n    height,\n    margin,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n    tooltip,\n    debug,\n    enableTouchCrosshair,\n}) => {\n    const { showTooltipAt, hideTooltip } = useTooltip()\n\n    const handleMouseEnter = useCallback(\n        (point, event) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            setCurrent(point)\n            onMouseEnter && onMouseEnter(point, event)\n        },\n        [setCurrent, showTooltipAt, tooltip, onMouseEnter, margin]\n    )\n\n    const handleMouseMove = useCallback(\n        (point, event) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            setCurrent(point)\n            onMouseMove && onMouseMove(point, event)\n        },\n        [showTooltipAt, tooltip, margin.left, margin.top, setCurrent, onMouseMove]\n    )\n\n    const handleMouseLeave = useCallback(\n        (point, event) => {\n            hideTooltip()\n            setCurrent(null)\n            onMouseLeave && onMouseLeave(point, event)\n        },\n        [hideTooltip, setCurrent, onMouseLeave]\n    )\n\n    const handleClick = useCallback(\n        (point, event) => {\n            onClick && onClick(point, event)\n        },\n        [onClick]\n    )\n\n    const handleTouchStart = useCallback(\n        (point, event) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            setCurrent(point)\n            onTouchStart && onTouchStart(point, event)\n        },\n        [margin.left, margin.top, onTouchStart, setCurrent, showTooltipAt, tooltip]\n    )\n\n    const handleTouchMove = useCallback(\n        (point, event) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            setCurrent(point)\n            onTouchMove && onTouchMove(point, event)\n        },\n        [margin.left, margin.top, onTouchMove, setCurrent, showTooltipAt, tooltip]\n    )\n\n    const handleTouchEnd = useCallback(\n        (point, event) => {\n            hideTooltip()\n            setCurrent(null)\n            onTouchEnd && onTouchEnd(point, event)\n        },\n        [onTouchEnd, hideTooltip, setCurrent]\n    )\n\n    return (\n        <BaseMesh\n            nodes={points}\n            width={width}\n            height={height}\n            onMouseEnter={handleMouseEnter}\n            onMouseMove={handleMouseMove}\n            onMouseLeave={handleMouseLeave}\n            onClick={handleClick}\n            onTouchStart={handleTouchStart}\n            onTouchMove={handleTouchMove}\n            onTouchEnd={handleTouchEnd}\n            enableTouchCrosshair={enableTouchCrosshair}\n            debug={debug}\n        />\n    )\n}\n\nMesh.propTypes = {\n    points: PropTypes.arrayOf(PropTypes.object).isRequired,\n    width: PropTypes.number.isRequired,\n    height: PropTypes.number.isRequired,\n    margin: PropTypes.object.isRequired,\n    setCurrent: PropTypes.func.isRequired,\n    onMouseEnter: PropTypes.func,\n    onMouseMove: PropTypes.func,\n    onMouseLeave: PropTypes.func,\n    onClick: PropTypes.func,\n    onTouchStart: PropTypes.func,\n    onTouchMove: PropTypes.func,\n    onTouchEnd: PropTypes.func,\n    tooltip: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,\n    debug: PropTypes.bool.isRequired,\n}\n\nexport default memo(Mesh)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { Fragment, useState } from 'react'\nimport {\n    bindDefs,\n    withContainer,\n    useDimensions,\n    useTheme,\n    SvgWrapper,\n    CartesianMarkers,\n} from '@nivo/core'\nimport { useInheritedColor } from '@nivo/colors'\nimport { Axes, Grid } from '@nivo/axes'\nimport { BoxLegendSvg } from '@nivo/legends'\nimport { Crosshair } from '@nivo/tooltip'\nimport { useLine } from './hooks'\nimport { LinePropTypes } from './props'\nimport Areas from './Areas'\nimport Lines from './Lines'\nimport Slices from './Slices'\nimport Points from './Points'\nimport Mesh from './Mesh'\nimport PointTooltip from './PointTooltip'\nimport SliceTooltip from './SliceTooltip'\n\nconst Line = props => {\n    const {\n        data,\n        xScale: xScaleSpec = { type: 'point' },\n        xFormat,\n        yScale: yScaleSpec = {\n            type: 'linear',\n            min: 0,\n            max: 'auto',\n        },\n        yFormat,\n        layers = [\n            'grid',\n            'markers',\n            'axes',\n            'areas',\n            'crosshair',\n            'lines',\n            'points',\n            'slices',\n            'mesh',\n            'legends',\n        ],\n        curve = 'linear',\n        areaBaselineValue = 0,\n\n        colors = { scheme: 'nivo' },\n\n        margin: partialMargin,\n        width,\n        height,\n\n        axisTop,\n        axisRight,\n        axisBottom = {},\n        axisLeft = {},\n        enableGridX = true,\n        enableGridY = true,\n        gridXValues,\n        gridYValues,\n\n        lineWidth = 2,\n        enableArea = false,\n        areaOpacity = 0.2,\n        areaBlendMode = 'normal',\n\n        enablePoints = true,\n        pointSymbol,\n        pointSize = 6,\n        pointColor = { from: 'color' },\n        pointBorderWidth = 0,\n        pointBorderColor = { theme: 'background' },\n        enablePointLabel = false,\n        pointLabel = 'yFormatted',\n        pointLabelYOffset,\n\n        defs = [],\n        fill = [],\n\n        markers,\n\n        legends = [],\n\n        isInteractive = true,\n\n        useMesh = false,\n        debugMesh = false,\n\n        onMouseEnter,\n        onMouseMove,\n        onMouseLeave,\n        onClick,\n        onTouchStart,\n        onTouchMove,\n        onTouchEnd,\n\n        tooltip = PointTooltip,\n\n        enableSlices = false,\n        debugSlices = false,\n        sliceTooltip = SliceTooltip,\n\n        enableCrosshair = true,\n        crosshairType = 'bottom-left',\n        enableTouchCrosshair = false,\n\n        role = 'img',\n    } = props\n\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const {\n        legendData,\n        toggleSerie,\n        lineGenerator,\n        areaGenerator,\n        series,\n        xScale,\n        yScale,\n        slices,\n        points,\n    } = useLine({\n        data,\n        xScale: xScaleSpec,\n        xFormat,\n        yScale: yScaleSpec,\n        yFormat,\n        width: innerWidth,\n        height: innerHeight,\n        colors,\n        curve,\n        areaBaselineValue,\n        pointColor,\n        pointBorderColor,\n        enableSlices,\n    })\n\n    const theme = useTheme()\n    const getPointColor = useInheritedColor(pointColor, theme)\n    const getPointBorderColor = useInheritedColor(pointBorderColor, theme)\n\n    const [currentPoint, setCurrentPoint] = useState(null)\n    const [currentSlice, setCurrentSlice] = useState(null)\n\n    const layerById = {\n        grid: (\n            <Grid\n                key=\"grid\"\n                theme={theme}\n                width={innerWidth}\n                height={innerHeight}\n                xScale={enableGridX ? xScale : null}\n                yScale={enableGridY ? yScale : null}\n                xValues={gridXValues}\n                yValues={gridYValues}\n            />\n        ),\n        markers: (\n            <CartesianMarkers\n                key=\"markers\"\n                markers={markers}\n                width={innerWidth}\n                height={innerHeight}\n                xScale={xScale}\n                yScale={yScale}\n                theme={theme}\n            />\n        ),\n        axes: (\n            <Axes\n                key=\"axes\"\n                xScale={xScale}\n                yScale={yScale}\n                width={innerWidth}\n                height={innerHeight}\n                theme={theme}\n                top={axisTop}\n                right={axisRight}\n                bottom={axisBottom}\n                left={axisLeft}\n            />\n        ),\n        areas: null,\n        lines: (\n            <Lines key=\"lines\" lines={series} lineGenerator={lineGenerator} lineWidth={lineWidth} />\n        ),\n        slices: null,\n        points: null,\n        crosshair: null,\n        mesh: null,\n        legends: legends.map((legend, i) => (\n            <BoxLegendSvg\n                key={`legend.${i}`}\n                {...legend}\n                containerWidth={innerWidth}\n                containerHeight={innerHeight}\n                data={legend.data || legendData}\n                theme={theme}\n                toggleSerie={legend.toggleSerie ? toggleSerie : undefined}\n            />\n        )),\n    }\n\n    const boundDefs = bindDefs(defs, series, fill)\n\n    if (enableArea) {\n        layerById.areas = (\n            <Areas\n                key=\"areas\"\n                areaGenerator={areaGenerator}\n                areaOpacity={areaOpacity}\n                areaBlendMode={areaBlendMode}\n                lines={series}\n            />\n        )\n    }\n\n    if (isInteractive && enableSlices !== false) {\n        layerById.slices = (\n            <Slices\n                key=\"slices\"\n                slices={slices}\n                axis={enableSlices}\n                debug={debugSlices}\n                height={innerHeight}\n                tooltip={sliceTooltip}\n                current={currentSlice}\n                setCurrent={setCurrentSlice}\n                onMouseEnter={onMouseEnter}\n                onMouseMove={onMouseMove}\n                onMouseLeave={onMouseLeave}\n                onClick={onClick}\n                onTouchStart={onTouchStart}\n                onTouchMove={onTouchMove}\n                onTouchEnd={onTouchEnd}\n            />\n        )\n    }\n\n    if (enablePoints) {\n        layerById.points = (\n            <Points\n                key=\"points\"\n                points={points}\n                symbol={pointSymbol}\n                size={pointSize}\n                color={getPointColor}\n                borderWidth={pointBorderWidth}\n                borderColor={getPointBorderColor}\n                enableLabel={enablePointLabel}\n                label={pointLabel}\n                labelYOffset={pointLabelYOffset}\n            />\n        )\n    }\n\n    if (isInteractive && enableCrosshair) {\n        if (currentPoint !== null) {\n            layerById.crosshair = (\n                <Crosshair\n                    key=\"crosshair\"\n                    width={innerWidth}\n                    height={innerHeight}\n                    x={currentPoint.x}\n                    y={currentPoint.y}\n                    type={crosshairType}\n                />\n            )\n        }\n        if (currentSlice !== null) {\n            layerById.crosshair = (\n                <Crosshair\n                    key=\"crosshair\"\n                    width={innerWidth}\n                    height={innerHeight}\n                    x={currentSlice.x}\n                    y={currentSlice.y}\n                    type={enableSlices}\n                />\n            )\n        }\n    }\n\n    if (isInteractive && useMesh && enableSlices === false) {\n        layerById.mesh = (\n            <Mesh\n                key=\"mesh\"\n                points={points}\n                width={innerWidth}\n                height={innerHeight}\n                margin={margin}\n                current={currentPoint}\n                setCurrent={setCurrentPoint}\n                onMouseEnter={onMouseEnter}\n                onMouseMove={onMouseMove}\n                onMouseLeave={onMouseLeave}\n                onClick={onClick}\n                onTouchStart={onTouchStart}\n                onTouchMove={onTouchMove}\n                onTouchEnd={onTouchEnd}\n                tooltip={tooltip}\n                enableTouchCrosshair={enableTouchCrosshair}\n                debug={debugMesh}\n            />\n        )\n    }\n\n    return (\n        <SvgWrapper\n            defs={boundDefs}\n            width={outerWidth}\n            height={outerHeight}\n            margin={margin}\n            role={role}\n        >\n            {layers.map((layer, i) => {\n                if (typeof layer === 'function') {\n                    return (\n                        <Fragment key={i}>\n                            {layer({\n                                ...props,\n                                innerWidth,\n                                innerHeight,\n                                series,\n                                slices,\n                                points,\n                                xScale,\n                                yScale,\n                                lineGenerator,\n                                areaGenerator,\n                                currentPoint,\n                                setCurrentPoint,\n                                currentSlice,\n                                setCurrentSlice,\n                            })}\n                        </Fragment>\n                    )\n                }\n\n                return layerById[layer]\n            })}\n        </SvgWrapper>\n    )\n}\n\nLine.propTypes = LinePropTypes\n\nexport default withContainer(Line)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { ResponsiveWrapper } from '@nivo/core'\nimport Line from './Line'\n\nconst ResponsiveLine = props => (\n    <ResponsiveWrapper>\n        {({ width, height }) => <Line width={width} height={height} {...props} />}\n    </ResponsiveWrapper>\n)\n\nexport default ResponsiveLine\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { createElement, useRef, useEffect, useState, useCallback, forwardRef } from 'react'\nimport {\n    withContainer,\n    useDimensions,\n    useTheme,\n    getRelativeCursor,\n    isCursorInRect,\n} from '@nivo/core'\nimport { renderAxesToCanvas, renderGridLinesToCanvas } from '@nivo/axes'\nimport { renderLegendToCanvas } from '@nivo/legends'\nimport { useTooltip } from '@nivo/tooltip'\nimport { useVoronoiMesh, renderVoronoiToCanvas, renderVoronoiCellToCanvas } from '@nivo/voronoi'\nimport { LineCanvasPropTypes } from './props'\nimport { useLine } from './hooks'\nimport PointTooltip from './PointTooltip'\n\nconst LineCanvas = props => {\n    const canvasEl = useRef(null)\n    const {\n        width,\n        height,\n        margin: partialMargin,\n        pixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1,\n\n        data,\n        xScale: xScaleSpec = { type: 'point' },\n        xFormat,\n        yScale: yScaleSpec = {\n            type: 'linear',\n            min: 0,\n            max: 'auto',\n        },\n        yFormat,\n        curve = 'linear',\n\n        layers = [\n            'grid',\n            'markers',\n            'axes',\n            'areas',\n            'crosshair',\n            'lines',\n            'points',\n            'slices',\n            'mesh',\n            'legends',\n        ],\n\n        colors = { scheme: 'nivo' },\n        lineWidth = 2,\n\n        enableArea = false,\n        areaBaselineValue = 0,\n        areaOpacity = 0.2,\n\n        enablePoints = true,\n        pointSize = 6,\n        pointColor = { from: 'color' },\n        pointBorderWidth = 0,\n        pointBorderColor = { theme: 'background' },\n\n        enableGridX = true,\n        gridXValues,\n        enableGridY = true,\n        gridYValues,\n        axisTop,\n        axisRight,\n        axisBottom = {},\n        axisLeft = {},\n\n        legends = [],\n\n        isInteractive = true,\n        debugMesh = false,\n        //onMouseEnter,\n        //onMouseMove,\n        onMouseLeave,\n        onClick,\n        tooltip = PointTooltip,\n        canvasRef,\n    } = props\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n    const theme = useTheme()\n    const [currentPoint, setCurrentPoint] = useState(null)\n\n    const { lineGenerator, areaGenerator, series, xScale, yScale, points } = useLine({\n        data,\n        xScale: xScaleSpec,\n        xFormat,\n        yScale: yScaleSpec,\n        yFormat,\n        width: innerWidth,\n        height: innerHeight,\n        colors,\n        curve,\n        areaBaselineValue,\n        pointColor,\n        pointBorderColor,\n    })\n\n    const { delaunay, voronoi } = useVoronoiMesh({\n        points,\n        width: innerWidth,\n        height: innerHeight,\n        debug: debugMesh,\n    })\n\n    useEffect(() => {\n        if (canvasRef) {\n            canvasRef.current = canvasEl.current\n        }\n\n        canvasEl.current.width = outerWidth * pixelRatio\n        canvasEl.current.height = outerHeight * pixelRatio\n\n        const ctx = canvasEl.current.getContext('2d')\n\n        ctx.scale(pixelRatio, pixelRatio)\n\n        ctx.fillStyle = theme.background\n        ctx.fillRect(0, 0, outerWidth, outerHeight)\n        ctx.translate(margin.left, margin.top)\n\n        layers.forEach(layer => {\n            if (typeof layer === 'function') {\n                layer({\n                    ctx,\n                    innerWidth,\n                    innerHeight,\n                    series,\n                    points,\n                    xScale,\n                    yScale,\n                    lineWidth,\n                    lineGenerator,\n                    areaGenerator,\n                    currentPoint,\n                    setCurrentPoint,\n                })\n            }\n\n            if (layer === 'grid' && theme.grid.line.strokeWidth > 0) {\n                ctx.lineWidth = theme.grid.line.strokeWidth\n                ctx.strokeStyle = theme.grid.line.stroke\n\n                enableGridX &&\n                    renderGridLinesToCanvas(ctx, {\n                        width: innerWidth,\n                        height: innerHeight,\n                        scale: xScale,\n                        axis: 'x',\n                        values: gridXValues,\n                    })\n\n                enableGridY &&\n                    renderGridLinesToCanvas(ctx, {\n                        width: innerWidth,\n                        height: innerHeight,\n                        scale: yScale,\n                        axis: 'y',\n                        values: gridYValues,\n                    })\n            }\n\n            if (layer === 'axes') {\n                renderAxesToCanvas(ctx, {\n                    xScale,\n                    yScale,\n                    width: innerWidth,\n                    height: innerHeight,\n                    top: axisTop,\n                    right: axisRight,\n                    bottom: axisBottom,\n                    left: axisLeft,\n                    theme,\n                })\n            }\n\n            if (layer === 'areas' && enableArea === true) {\n                ctx.save()\n                ctx.globalAlpha = areaOpacity\n\n                areaGenerator.context(ctx)\n                series.forEach(serie => {\n                    ctx.fillStyle = serie.color\n                    ctx.beginPath()\n                    areaGenerator(serie.data.map(d => d.position))\n                    ctx.fill()\n                })\n\n                ctx.restore()\n            }\n\n            if (layer === 'lines') {\n                lineGenerator.context(ctx)\n                series.forEach(serie => {\n                    ctx.strokeStyle = serie.color\n                    ctx.lineWidth = lineWidth\n                    ctx.beginPath()\n                    lineGenerator(serie.data.map(d => d.position))\n                    ctx.stroke()\n                })\n            }\n\n            if (layer === 'points' && enablePoints === true && pointSize > 0) {\n                points.forEach(point => {\n                    ctx.fillStyle = point.color\n                    ctx.beginPath()\n                    ctx.arc(point.x, point.y, pointSize / 2, 0, 2 * Math.PI)\n                    ctx.fill()\n\n                    if (pointBorderWidth > 0) {\n                        ctx.strokeStyle = point.borderColor\n                        ctx.lineWidth = pointBorderWidth\n                        ctx.stroke()\n                    }\n                })\n            }\n\n            if (layer === 'mesh' && debugMesh === true) {\n                renderVoronoiToCanvas(ctx, voronoi)\n                if (currentPoint) {\n                    renderVoronoiCellToCanvas(ctx, voronoi, currentPoint.index)\n                }\n            }\n\n            if (layer === 'legends') {\n                const legendData = series\n                    .map(serie => ({\n                        id: serie.id,\n                        label: serie.id,\n                        color: serie.color,\n                    }))\n                    .reverse()\n\n                legends.forEach(legend => {\n                    renderLegendToCanvas(ctx, {\n                        ...legend,\n                        data: legend.data || legendData,\n                        containerWidth: innerWidth,\n                        containerHeight: innerHeight,\n                        theme,\n                    })\n                })\n            }\n        })\n    }, [\n        canvasEl,\n        outerWidth,\n        outerHeight,\n        layers,\n        theme,\n        lineGenerator,\n        series,\n        xScale,\n        yScale,\n        enableGridX,\n        gridXValues,\n        enableGridY,\n        gridYValues,\n        axisTop,\n        axisRight,\n        axisBottom,\n        axisLeft,\n        legends,\n        points,\n        enablePoints,\n        pointSize,\n        currentPoint,\n    ])\n\n    const getPointFromMouseEvent = useCallback(\n        event => {\n            const [x, y] = getRelativeCursor(canvasEl.current, event)\n            if (!isCursorInRect(margin.left, margin.top, innerWidth, innerHeight, x, y)) return null\n\n            const pointIndex = delaunay.find(x - margin.left, y - margin.top)\n            return points[pointIndex]\n        },\n        [canvasEl, margin, innerWidth, innerHeight, delaunay]\n    )\n\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const handleMouseHover = useCallback(\n        event => {\n            const point = getPointFromMouseEvent(event)\n            setCurrentPoint(point)\n\n            if (point) {\n                showTooltipFromEvent(createElement(tooltip, { point }), event)\n            } else {\n                hideTooltip()\n            }\n        },\n        [getPointFromMouseEvent, setCurrentPoint, showTooltipFromEvent, hideTooltip, tooltip]\n    )\n\n    const handleMouseLeave = useCallback(\n        event => {\n            hideTooltip()\n            setCurrentPoint(null)\n            currentPoint && onMouseLeave && onMouseLeave(currentPoint, event)\n        },\n        [hideTooltip, setCurrentPoint, onMouseLeave]\n    )\n\n    const handleClick = useCallback(\n        event => {\n            if (onClick) {\n                const point = getPointFromMouseEvent(event)\n                point && onClick(point, event)\n            }\n        },\n        [getPointFromMouseEvent, onClick]\n    )\n\n    return (\n        <canvas\n            ref={canvasEl}\n            width={outerWidth * pixelRatio}\n            height={outerHeight * pixelRatio}\n            style={{\n                width: outerWidth,\n                height: outerHeight,\n                cursor: isInteractive ? 'auto' : 'normal',\n            }}\n            onMouseEnter={isInteractive ? handleMouseHover : undefined}\n            onMouseMove={isInteractive ? handleMouseHover : undefined}\n            onMouseLeave={isInteractive ? handleMouseLeave : undefined}\n            onClick={isInteractive ? handleClick : undefined}\n        />\n    )\n}\n\nLineCanvas.propTypes = LineCanvasPropTypes\n\nconst LineCanvasWithContainer = withContainer(LineCanvas)\n\nexport default forwardRef((props, ref) => <LineCanvasWithContainer {...props} canvasRef={ref} />)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { forwardRef } from 'react'\nimport { ResponsiveWrapper } from '@nivo/core'\nimport LineCanvas from './LineCanvas'\n\nconst ResponsiveLineCanvas = (props, ref) => (\n    <ResponsiveWrapper>\n        {({ width, height }) => <LineCanvas width={width} height={height} {...props} ref={ref} />}\n    </ResponsiveWrapper>\n)\n\nexport default forwardRef(ResponsiveLineCanvas)\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}