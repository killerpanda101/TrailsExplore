{"ast":null,"code":"import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nconst _excluded = [\"style\"];\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { useForkRef } from '@mui/material/utils';\nimport { useGridApiContext } from '../../utils/useGridApiContext';\nimport { useGridRootProps } from '../../utils/useGridRootProps';\nimport { useGridSelector } from '../../utils/useGridSelector';\nimport { gridVisibleColumnDefinitionsSelector, gridColumnsTotalWidthSelector, gridColumnPositionsSelector } from '../columns/gridColumnsSelector';\nimport { gridDensityRowHeightSelector } from '../density/densitySelector';\nimport { gridFocusCellSelector, gridTabIndexCellSelector } from '../focus/gridFocusStateSelector';\nimport { gridEditRowsStateSelector } from '../editRows/gridEditRowsSelector';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { clamp } from '../../../utils/utils';\nimport { selectedIdsLookupSelector } from '../selection/gridSelectionSelector';\nimport { gridRowsMetaSelector } from '../rows/gridRowsMetaSelector';\nimport { getFirstNonSpannedColumnToRender } from '../columns/gridColumnsUtils'; // Uses binary search to avoid looping through all possible positions\n\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport function binarySearch(offset, positions, sliceStart = 0, sliceEnd = positions.length) {\n  if (positions.length <= 0) {\n    return -1;\n  }\n  if (sliceStart >= sliceEnd) {\n    return sliceStart;\n  }\n  const pivot = sliceStart + Math.floor((sliceEnd - sliceStart) / 2);\n  const itemOffset = positions[pivot];\n  return offset <= itemOffset ? binarySearch(offset, positions, sliceStart, pivot) : binarySearch(offset, positions, pivot + 1, sliceEnd);\n}\nfunction exponentialSearch(offset, positions, index) {\n  let interval = 1;\n  while (index < positions.length && positions[index] < offset) {\n    index += interval;\n    interval *= 2;\n  }\n  return binarySearch(offset, positions, Math.floor(index / 2), Math.min(index, positions.length));\n}\nexport const getRenderableIndexes = ({\n  firstIndex,\n  lastIndex,\n  buffer,\n  minFirstIndex,\n  maxLastIndex\n}) => {\n  return [clamp(firstIndex - buffer, minFirstIndex, maxLastIndex), clamp(lastIndex + buffer, minFirstIndex, maxLastIndex)];\n};\nexport const useGridVirtualScroller = props => {\n  var _currentPage$range3, _currentPage$range4;\n  const apiRef = useGridApiContext();\n  const rootProps = useGridRootProps();\n  const visibleColumns = useGridSelector(apiRef, gridVisibleColumnDefinitionsSelector);\n  const {\n    ref,\n    disableVirtualization,\n    onRenderZonePositioning,\n    renderZoneMinColumnIndex = 0,\n    renderZoneMaxColumnIndex = visibleColumns.length,\n    getRowProps\n  } = props;\n  const columnPositions = useGridSelector(apiRef, gridColumnPositionsSelector);\n  const columnsTotalWidth = useGridSelector(apiRef, gridColumnsTotalWidthSelector);\n  const rowHeight = useGridSelector(apiRef, gridDensityRowHeightSelector);\n  const cellFocus = useGridSelector(apiRef, gridFocusCellSelector);\n  const cellTabIndex = useGridSelector(apiRef, gridTabIndexCellSelector);\n  const rowsMeta = useGridSelector(apiRef, gridRowsMetaSelector);\n  const editRowsState = useGridSelector(apiRef, gridEditRowsStateSelector);\n  const selectedRowsLookup = useGridSelector(apiRef, selectedIdsLookupSelector);\n  const currentPage = useGridVisibleRows(apiRef, rootProps);\n  const renderZoneRef = React.useRef(null);\n  const rootRef = React.useRef(null);\n  const handleRef = useForkRef(ref, rootRef);\n  const [renderContext, setRenderContext] = React.useState(null);\n  const prevRenderContext = React.useRef(renderContext);\n  const scrollPosition = React.useRef({\n    top: 0,\n    left: 0\n  });\n  const [containerWidth, setContainerWidth] = React.useState(null);\n  const prevTotalWidth = React.useRef(columnsTotalWidth);\n  const getNearestIndexToRender = React.useCallback(offset => {\n    var _currentPage$range, _currentPage$range2;\n    const lastMeasuredIndexRelativeToAllRows = apiRef.current.unstable_getLastMeasuredRowIndex();\n    const lastMeasuredIndexRelativeToCurrentPage = lastMeasuredIndexRelativeToAllRows - (((_currentPage$range = currentPage.range) == null ? void 0 : _currentPage$range.firstRowIndex) || 0);\n    const lastMeasuredIndex = Math.max(0, lastMeasuredIndexRelativeToCurrentPage);\n    let allRowsMeasured = lastMeasuredIndex === Infinity;\n    if ((_currentPage$range2 = currentPage.range) != null && _currentPage$range2.lastRowIndex && !allRowsMeasured) {\n      // Check if all rows in this page are already measured\n      allRowsMeasured = lastMeasuredIndex >= currentPage.range.lastRowIndex;\n    }\n    if (allRowsMeasured || rowsMeta.positions[lastMeasuredIndex] >= offset) {\n      // If all rows were measured (when no row has \"auto\" as height) or all rows before the offset\n      // were measured, then use a binary search because it's faster.\n      return binarySearch(offset, rowsMeta.positions);\n    } // Otherwise, use an exponential search.\n    // If rows have \"auto\" as height, their positions will be based on estimated heights.\n    // In this case, we can skip several steps until we find a position higher than the offset.\n    // Inspired by https://github.com/bvaughn/react-virtualized/blob/master/source/Grid/utils/CellSizeAndPositionManager.js\n\n    return exponentialSearch(offset, rowsMeta.positions, lastMeasuredIndex);\n  }, [apiRef, (_currentPage$range3 = currentPage.range) == null ? void 0 : _currentPage$range3.firstRowIndex, (_currentPage$range4 = currentPage.range) == null ? void 0 : _currentPage$range4.lastRowIndex, rowsMeta.positions]);\n  const computeRenderContext = React.useCallback(() => {\n    if (disableVirtualization) {\n      return {\n        firstRowIndex: 0,\n        lastRowIndex: currentPage.rows.length,\n        firstColumnIndex: 0,\n        lastColumnIndex: visibleColumns.length\n      };\n    }\n    const {\n      top,\n      left\n    } = scrollPosition.current; // Clamp the value because the search may return an index out of bounds.\n    // In the last index, this is not needed because Array.slice doesn't include it.\n\n    const firstRowIndex = Math.min(getNearestIndexToRender(top), rowsMeta.positions.length - 1);\n    const lastRowIndex = rootProps.autoHeight ? firstRowIndex + currentPage.rows.length : getNearestIndexToRender(top + rootRef.current.clientHeight);\n    let hasRowWithAutoHeight = false;\n    let firstColumnIndex = 0;\n    let lastColumnIndex = columnPositions.length;\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\n      firstIndex: firstRowIndex,\n      lastIndex: lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rootProps.rowBuffer\n    });\n    for (let i = firstRowToRender; i < lastRowToRender && !hasRowWithAutoHeight; i += 1) {\n      const row = currentPage.rows[i];\n      hasRowWithAutoHeight = apiRef.current.unstable_rowHasAutoHeight(row.id);\n    }\n    if (!hasRowWithAutoHeight) {\n      firstColumnIndex = binarySearch(left, columnPositions);\n      lastColumnIndex = binarySearch(left + containerWidth, columnPositions);\n    }\n    return {\n      firstRowIndex,\n      lastRowIndex,\n      firstColumnIndex,\n      lastColumnIndex\n    };\n  }, [disableVirtualization, getNearestIndexToRender, rowsMeta.positions.length, rootProps.autoHeight, rootProps.rowBuffer, currentPage.rows, columnPositions, visibleColumns.length, apiRef, containerWidth]);\n  React.useEffect(() => {\n    if (disableVirtualization) {\n      renderZoneRef.current.style.transform = `translate3d(0px, 0px, 0px)`;\n    } else {\n      // TODO a scroll reset should not be necessary\n      rootRef.current.scrollLeft = 0;\n      rootRef.current.scrollTop = 0;\n    }\n  }, [disableVirtualization]);\n  React.useEffect(() => {\n    setContainerWidth(rootRef.current.clientWidth);\n  }, [rowsMeta.currentPageTotalHeight]);\n  const handleResize = React.useCallback(params => {\n    setContainerWidth(params.width);\n  }, []);\n  useGridApiEventHandler(apiRef, 'resize', handleResize);\n  const updateRenderZonePosition = React.useCallback(nextRenderContext => {\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstRowIndex,\n      lastIndex: nextRenderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rootProps.rowBuffer\n    });\n    const [initialFirstColumnToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstColumnIndex,\n      lastIndex: nextRenderContext.lastColumnIndex,\n      minFirstIndex: renderZoneMinColumnIndex,\n      maxLastIndex: renderZoneMaxColumnIndex,\n      buffer: rootProps.columnBuffer\n    });\n    const firstColumnToRender = getFirstNonSpannedColumnToRender({\n      firstColumnToRender: initialFirstColumnToRender,\n      apiRef,\n      firstRowToRender,\n      lastRowToRender,\n      visibleRows: currentPage.rows\n    });\n    const top = gridRowsMetaSelector(apiRef.current.state).positions[firstRowToRender];\n    const left = gridColumnPositionsSelector(apiRef)[firstColumnToRender]; // Call directly the selector because it might be outdated when this method is called\n\n    renderZoneRef.current.style.transform = `translate3d(${left}px, ${top}px, 0px)`;\n    if (typeof onRenderZonePositioning === 'function') {\n      onRenderZonePositioning({\n        top,\n        left\n      });\n    }\n  }, [apiRef, currentPage.rows, onRenderZonePositioning, renderZoneMinColumnIndex, renderZoneMaxColumnIndex, rootProps.columnBuffer, rootProps.rowBuffer]);\n  React.useLayoutEffect(() => {\n    if (renderContext) {\n      updateRenderZonePosition(renderContext);\n    }\n  }, [renderContext, updateRenderZonePosition]);\n  const updateRenderContext = React.useCallback(nextRenderContext => {\n    setRenderContext(nextRenderContext);\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstRowIndex,\n      lastIndex: nextRenderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rootProps.rowBuffer\n    });\n    apiRef.current.publishEvent('renderedRowsIntervalChange', {\n      firstRowToRender,\n      lastRowToRender\n    });\n    prevRenderContext.current = nextRenderContext;\n  }, [apiRef, setRenderContext, prevRenderContext, currentPage.rows.length, rootProps.rowBuffer]);\n  React.useEffect(() => {\n    if (containerWidth == null) {\n      return;\n    }\n    const initialRenderContext = computeRenderContext();\n    updateRenderContext(initialRenderContext);\n    const {\n      top,\n      left\n    } = scrollPosition.current;\n    const params = {\n      top,\n      left,\n      renderContext: initialRenderContext\n    };\n    apiRef.current.publishEvent('rowsScroll', params);\n  }, [apiRef, computeRenderContext, containerWidth, updateRenderContext]);\n  const handleScroll = event => {\n    const {\n      scrollTop,\n      scrollLeft\n    } = event.currentTarget;\n    scrollPosition.current.top = scrollTop;\n    scrollPosition.current.left = scrollLeft; // On iOS and macOS, negative offsets are possible when swiping past the start\n\n    if (scrollLeft < 0 || scrollTop < 0 || !prevRenderContext.current) {\n      return;\n    } // When virtualization is disabled, the context never changes during scroll\n\n    const nextRenderContext = disableVirtualization ? prevRenderContext.current : computeRenderContext();\n    const topRowsScrolledSincePreviousRender = Math.abs(nextRenderContext.firstRowIndex - prevRenderContext.current.firstRowIndex);\n    const bottomRowsScrolledSincePreviousRender = Math.abs(nextRenderContext.lastRowIndex - prevRenderContext.current.lastRowIndex);\n    const topColumnsScrolledSincePreviousRender = Math.abs(nextRenderContext.firstColumnIndex - prevRenderContext.current.firstColumnIndex);\n    const bottomColumnsScrolledSincePreviousRender = Math.abs(nextRenderContext.lastColumnIndex - prevRenderContext.current.lastColumnIndex);\n    const shouldSetState = topRowsScrolledSincePreviousRender >= rootProps.rowThreshold || bottomRowsScrolledSincePreviousRender >= rootProps.rowThreshold || topColumnsScrolledSincePreviousRender >= rootProps.columnThreshold || bottomColumnsScrolledSincePreviousRender >= rootProps.columnThreshold || prevTotalWidth.current !== columnsTotalWidth; // TODO v6: rename event to a wider name, it's not only fired for row scrolling\n\n    apiRef.current.publishEvent('rowsScroll', {\n      top: scrollTop,\n      left: scrollLeft,\n      renderContext: shouldSetState ? nextRenderContext : prevRenderContext.current\n    }, event);\n    if (shouldSetState) {\n      // Prevents batching render context changes\n      ReactDOM.flushSync(() => {\n        updateRenderContext(nextRenderContext);\n      });\n      prevTotalWidth.current = columnsTotalWidth;\n    }\n  };\n  const handleWheel = event => {\n    apiRef.current.publishEvent('virtualScrollerWheel', {}, event);\n  };\n  const handleTouchMove = event => {\n    apiRef.current.publishEvent('virtualScrollerTouchMove', {}, event);\n  };\n  const getRows = (params = {\n    renderContext\n  }) => {\n    const {\n      renderContext: nextRenderContext,\n      minFirstColumn = renderZoneMinColumnIndex,\n      maxLastColumn = renderZoneMaxColumnIndex,\n      availableSpace = containerWidth,\n      rowIndexOffset = 0,\n      position = 'center'\n    } = params;\n    if (!nextRenderContext || availableSpace == null) {\n      return null;\n    }\n    const rowBuffer = !disableVirtualization ? rootProps.rowBuffer : 0;\n    const columnBuffer = !disableVirtualization ? rootProps.columnBuffer : 0;\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstRowIndex,\n      lastIndex: nextRenderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rowBuffer\n    });\n    const renderedRows = [];\n    if (params.rows) {\n      params.rows.forEach(row => {\n        renderedRows.push(row);\n        apiRef.current.unstable_calculateColSpan({\n          rowId: row.id,\n          minFirstColumn,\n          maxLastColumn,\n          columns: visibleColumns\n        });\n      });\n    } else {\n      if (!currentPage.range) {\n        return null;\n      }\n      for (let i = firstRowToRender; i < lastRowToRender; i += 1) {\n        const row = currentPage.rows[i];\n        renderedRows.push(row);\n        apiRef.current.unstable_calculateColSpan({\n          rowId: row.id,\n          minFirstColumn,\n          maxLastColumn,\n          columns: visibleColumns\n        });\n      }\n    }\n    const [initialFirstColumnToRender, lastColumnToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstColumnIndex,\n      lastIndex: nextRenderContext.lastColumnIndex,\n      minFirstIndex: minFirstColumn,\n      maxLastIndex: maxLastColumn,\n      buffer: columnBuffer\n    });\n    const firstColumnToRender = getFirstNonSpannedColumnToRender({\n      firstColumnToRender: initialFirstColumnToRender,\n      apiRef,\n      firstRowToRender,\n      lastRowToRender,\n      visibleRows: currentPage.rows\n    });\n    const renderedColumns = visibleColumns.slice(firstColumnToRender, lastColumnToRender);\n    const rows = [];\n    for (let i = 0; i < renderedRows.length; i += 1) {\n      var _currentPage$range5, _rootProps$components;\n      const {\n        id,\n        model\n      } = renderedRows[i];\n      const lastVisibleRowIndex = firstRowToRender + i === currentPage.rows.length - 1;\n      const baseRowHeight = !apiRef.current.unstable_rowHasAutoHeight(id) ? apiRef.current.unstable_getRowHeight(id) : 'auto';\n      let isSelected;\n      if (selectedRowsLookup[id] == null) {\n        isSelected = false;\n      } else {\n        isSelected = apiRef.current.isRowSelectable(id);\n      }\n      rows.push( /*#__PURE__*/_jsx(rootProps.components.Row, _extends({\n        row: model,\n        rowId: id,\n        rowHeight: baseRowHeight,\n        cellFocus: cellFocus // TODO move to inside the row\n        ,\n\n        cellTabIndex: cellTabIndex // TODO move to inside the row\n        ,\n\n        editRowsState: editRowsState // TODO move to inside the row\n        ,\n\n        renderedColumns: renderedColumns,\n        visibleColumns: visibleColumns,\n        firstColumnToRender: firstColumnToRender,\n        lastColumnToRender: lastColumnToRender,\n        selected: isSelected,\n        index: rowIndexOffset + ((currentPage == null ? void 0 : (_currentPage$range5 = currentPage.range) == null ? void 0 : _currentPage$range5.firstRowIndex) || 0) + firstRowToRender + i,\n        containerWidth: availableSpace,\n        isLastVisible: lastVisibleRowIndex,\n        position: position\n      }, typeof getRowProps === 'function' ? getRowProps(id, model) : {}, (_rootProps$components = rootProps.componentsProps) == null ? void 0 : _rootProps$components.row), id));\n    }\n    return rows;\n  };\n  const needsHorizontalScrollbar = containerWidth && columnsTotalWidth > containerWidth;\n  const contentSize = React.useMemo(() => {\n    // In cases where the columns exceed the available width,\n    // the horizontal scrollbar should be shown even when there're no rows.\n    // Keeping 1px as minimum height ensures that the scrollbar will visible if necessary.\n    const height = Math.max(rowsMeta.currentPageTotalHeight, 1);\n    let shouldExtendContent = false;\n    if (rootRef != null && rootRef.current && height <= (rootRef == null ? void 0 : rootRef.current.clientHeight)) {\n      shouldExtendContent = true;\n    }\n    const size = {\n      width: needsHorizontalScrollbar ? columnsTotalWidth : 'auto',\n      height,\n      minHeight: shouldExtendContent ? '100%' : 'auto'\n    };\n    if (rootProps.autoHeight && currentPage.rows.length === 0) {\n      size.height = 2 * rowHeight; // Give room to show the overlay when there's no row.\n    }\n    return size;\n  }, [rootRef, columnsTotalWidth, rowsMeta.currentPageTotalHeight, currentPage.rows.length, needsHorizontalScrollbar, rootProps.autoHeight, rowHeight]);\n  React.useEffect(() => {\n    apiRef.current.publishEvent('virtualScrollerContentSizeChange');\n  }, [apiRef, contentSize]);\n  if (rootProps.autoHeight && currentPage.rows.length === 0) {\n    contentSize.height = 2 * rowHeight; // Give room to show the overlay when there no rows.\n  }\n  const rootStyle = {};\n  if (!needsHorizontalScrollbar) {\n    rootStyle.overflowX = 'hidden';\n  }\n  if (rootProps.autoHeight) {\n    rootStyle.overflowY = 'hidden';\n  }\n  const getRenderContext = React.useCallback(() => {\n    return prevRenderContext.current;\n  }, []);\n  apiRef.current.unstable_getRenderContext = getRenderContext;\n  return {\n    renderContext,\n    updateRenderZonePosition,\n    getRows,\n    getRootProps: (_ref = {}) => {\n      let {\n          style = {}\n        } = _ref,\n        other = _objectWithoutPropertiesLoose(_ref, _excluded);\n      return _extends({\n        ref: handleRef,\n        onScroll: handleScroll,\n        onWheel: handleWheel,\n        onTouchMove: handleTouchMove,\n        style: _extends({}, style, rootStyle)\n      }, other);\n    },\n    getContentProps: ({\n      style = {}\n    } = {}) => ({\n      style: _extends({}, style, contentSize)\n    }),\n    getRenderZoneProps: () => ({\n      ref: renderZoneRef\n    })\n  };\n};","map":{"version":3,"names":["_objectWithoutPropertiesLoose","_extends","_excluded","React","ReactDOM","useForkRef","useGridApiContext","useGridRootProps","useGridSelector","gridVisibleColumnDefinitionsSelector","gridColumnsTotalWidthSelector","gridColumnPositionsSelector","gridDensityRowHeightSelector","gridFocusCellSelector","gridTabIndexCellSelector","gridEditRowsStateSelector","useGridVisibleRows","useGridApiEventHandler","clamp","selectedIdsLookupSelector","gridRowsMetaSelector","getFirstNonSpannedColumnToRender","jsx","_jsx","binarySearch","offset","positions","sliceStart","sliceEnd","length","pivot","Math","floor","itemOffset","exponentialSearch","index","interval","min","getRenderableIndexes","firstIndex","lastIndex","buffer","minFirstIndex","maxLastIndex","useGridVirtualScroller","props","_currentPage$range3","_currentPage$range4","apiRef","rootProps","visibleColumns","ref","disableVirtualization","onRenderZonePositioning","renderZoneMinColumnIndex","renderZoneMaxColumnIndex","getRowProps","columnPositions","columnsTotalWidth","rowHeight","cellFocus","cellTabIndex","rowsMeta","editRowsState","selectedRowsLookup","currentPage","renderZoneRef","useRef","rootRef","handleRef","renderContext","setRenderContext","useState","prevRenderContext","scrollPosition","top","left","containerWidth","setContainerWidth","prevTotalWidth","getNearestIndexToRender","useCallback","_currentPage$range","_currentPage$range2","lastMeasuredIndexRelativeToAllRows","current","unstable_getLastMeasuredRowIndex","lastMeasuredIndexRelativeToCurrentPage","range","firstRowIndex","lastMeasuredIndex","max","allRowsMeasured","Infinity","lastRowIndex","computeRenderContext","rows","firstColumnIndex","lastColumnIndex","autoHeight","clientHeight","hasRowWithAutoHeight","firstRowToRender","lastRowToRender","rowBuffer","i","row","unstable_rowHasAutoHeight","id","useEffect","style","transform","scrollLeft","scrollTop","clientWidth","currentPageTotalHeight","handleResize","params","width","updateRenderZonePosition","nextRenderContext","initialFirstColumnToRender","columnBuffer","firstColumnToRender","visibleRows","state","useLayoutEffect","updateRenderContext","publishEvent","initialRenderContext","handleScroll","event","currentTarget","topRowsScrolledSincePreviousRender","abs","bottomRowsScrolledSincePreviousRender","topColumnsScrolledSincePreviousRender","bottomColumnsScrolledSincePreviousRender","shouldSetState","rowThreshold","columnThreshold","flushSync","handleWheel","handleTouchMove","getRows","minFirstColumn","maxLastColumn","availableSpace","rowIndexOffset","position","renderedRows","forEach","push","unstable_calculateColSpan","rowId","columns","lastColumnToRender","renderedColumns","slice","_currentPage$range5","_rootProps$components","model","lastVisibleRowIndex","baseRowHeight","unstable_getRowHeight","isSelected","isRowSelectable","components","Row","selected","isLastVisible","componentsProps","needsHorizontalScrollbar","contentSize","useMemo","height","shouldExtendContent","size","minHeight","rootStyle","overflowX","overflowY","getRenderContext","unstable_getRenderContext","getRootProps","_ref","other","onScroll","onWheel","onTouchMove","getContentProps","getRenderZoneProps"],"sources":["/Users/parijatchatterjee/Desktop/react-admin-dashboard/node_modules/@mui/x-data-grid/hooks/features/virtualization/useGridVirtualScroller.js"],"sourcesContent":["import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nconst _excluded = [\"style\"];\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { useForkRef } from '@mui/material/utils';\nimport { useGridApiContext } from '../../utils/useGridApiContext';\nimport { useGridRootProps } from '../../utils/useGridRootProps';\nimport { useGridSelector } from '../../utils/useGridSelector';\nimport { gridVisibleColumnDefinitionsSelector, gridColumnsTotalWidthSelector, gridColumnPositionsSelector } from '../columns/gridColumnsSelector';\nimport { gridDensityRowHeightSelector } from '../density/densitySelector';\nimport { gridFocusCellSelector, gridTabIndexCellSelector } from '../focus/gridFocusStateSelector';\nimport { gridEditRowsStateSelector } from '../editRows/gridEditRowsSelector';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { clamp } from '../../../utils/utils';\nimport { selectedIdsLookupSelector } from '../selection/gridSelectionSelector';\nimport { gridRowsMetaSelector } from '../rows/gridRowsMetaSelector';\nimport { getFirstNonSpannedColumnToRender } from '../columns/gridColumnsUtils'; // Uses binary search to avoid looping through all possible positions\n\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport function binarySearch(offset, positions, sliceStart = 0, sliceEnd = positions.length) {\n  if (positions.length <= 0) {\n    return -1;\n  }\n\n  if (sliceStart >= sliceEnd) {\n    return sliceStart;\n  }\n\n  const pivot = sliceStart + Math.floor((sliceEnd - sliceStart) / 2);\n  const itemOffset = positions[pivot];\n  return offset <= itemOffset ? binarySearch(offset, positions, sliceStart, pivot) : binarySearch(offset, positions, pivot + 1, sliceEnd);\n}\n\nfunction exponentialSearch(offset, positions, index) {\n  let interval = 1;\n\n  while (index < positions.length && positions[index] < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return binarySearch(offset, positions, Math.floor(index / 2), Math.min(index, positions.length));\n}\n\nexport const getRenderableIndexes = ({\n  firstIndex,\n  lastIndex,\n  buffer,\n  minFirstIndex,\n  maxLastIndex\n}) => {\n  return [clamp(firstIndex - buffer, minFirstIndex, maxLastIndex), clamp(lastIndex + buffer, minFirstIndex, maxLastIndex)];\n};\nexport const useGridVirtualScroller = props => {\n  var _currentPage$range3, _currentPage$range4;\n\n  const apiRef = useGridApiContext();\n  const rootProps = useGridRootProps();\n  const visibleColumns = useGridSelector(apiRef, gridVisibleColumnDefinitionsSelector);\n  const {\n    ref,\n    disableVirtualization,\n    onRenderZonePositioning,\n    renderZoneMinColumnIndex = 0,\n    renderZoneMaxColumnIndex = visibleColumns.length,\n    getRowProps\n  } = props;\n  const columnPositions = useGridSelector(apiRef, gridColumnPositionsSelector);\n  const columnsTotalWidth = useGridSelector(apiRef, gridColumnsTotalWidthSelector);\n  const rowHeight = useGridSelector(apiRef, gridDensityRowHeightSelector);\n  const cellFocus = useGridSelector(apiRef, gridFocusCellSelector);\n  const cellTabIndex = useGridSelector(apiRef, gridTabIndexCellSelector);\n  const rowsMeta = useGridSelector(apiRef, gridRowsMetaSelector);\n  const editRowsState = useGridSelector(apiRef, gridEditRowsStateSelector);\n  const selectedRowsLookup = useGridSelector(apiRef, selectedIdsLookupSelector);\n  const currentPage = useGridVisibleRows(apiRef, rootProps);\n  const renderZoneRef = React.useRef(null);\n  const rootRef = React.useRef(null);\n  const handleRef = useForkRef(ref, rootRef);\n  const [renderContext, setRenderContext] = React.useState(null);\n  const prevRenderContext = React.useRef(renderContext);\n  const scrollPosition = React.useRef({\n    top: 0,\n    left: 0\n  });\n  const [containerWidth, setContainerWidth] = React.useState(null);\n  const prevTotalWidth = React.useRef(columnsTotalWidth);\n  const getNearestIndexToRender = React.useCallback(offset => {\n    var _currentPage$range, _currentPage$range2;\n\n    const lastMeasuredIndexRelativeToAllRows = apiRef.current.unstable_getLastMeasuredRowIndex();\n    const lastMeasuredIndexRelativeToCurrentPage = lastMeasuredIndexRelativeToAllRows - (((_currentPage$range = currentPage.range) == null ? void 0 : _currentPage$range.firstRowIndex) || 0);\n    const lastMeasuredIndex = Math.max(0, lastMeasuredIndexRelativeToCurrentPage);\n    let allRowsMeasured = lastMeasuredIndex === Infinity;\n\n    if ((_currentPage$range2 = currentPage.range) != null && _currentPage$range2.lastRowIndex && !allRowsMeasured) {\n      // Check if all rows in this page are already measured\n      allRowsMeasured = lastMeasuredIndex >= currentPage.range.lastRowIndex;\n    }\n\n    if (allRowsMeasured || rowsMeta.positions[lastMeasuredIndex] >= offset) {\n      // If all rows were measured (when no row has \"auto\" as height) or all rows before the offset\n      // were measured, then use a binary search because it's faster.\n      return binarySearch(offset, rowsMeta.positions);\n    } // Otherwise, use an exponential search.\n    // If rows have \"auto\" as height, their positions will be based on estimated heights.\n    // In this case, we can skip several steps until we find a position higher than the offset.\n    // Inspired by https://github.com/bvaughn/react-virtualized/blob/master/source/Grid/utils/CellSizeAndPositionManager.js\n\n\n    return exponentialSearch(offset, rowsMeta.positions, lastMeasuredIndex);\n  }, [apiRef, (_currentPage$range3 = currentPage.range) == null ? void 0 : _currentPage$range3.firstRowIndex, (_currentPage$range4 = currentPage.range) == null ? void 0 : _currentPage$range4.lastRowIndex, rowsMeta.positions]);\n  const computeRenderContext = React.useCallback(() => {\n    if (disableVirtualization) {\n      return {\n        firstRowIndex: 0,\n        lastRowIndex: currentPage.rows.length,\n        firstColumnIndex: 0,\n        lastColumnIndex: visibleColumns.length\n      };\n    }\n\n    const {\n      top,\n      left\n    } = scrollPosition.current; // Clamp the value because the search may return an index out of bounds.\n    // In the last index, this is not needed because Array.slice doesn't include it.\n\n    const firstRowIndex = Math.min(getNearestIndexToRender(top), rowsMeta.positions.length - 1);\n    const lastRowIndex = rootProps.autoHeight ? firstRowIndex + currentPage.rows.length : getNearestIndexToRender(top + rootRef.current.clientHeight);\n    let hasRowWithAutoHeight = false;\n    let firstColumnIndex = 0;\n    let lastColumnIndex = columnPositions.length;\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\n      firstIndex: firstRowIndex,\n      lastIndex: lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rootProps.rowBuffer\n    });\n\n    for (let i = firstRowToRender; i < lastRowToRender && !hasRowWithAutoHeight; i += 1) {\n      const row = currentPage.rows[i];\n      hasRowWithAutoHeight = apiRef.current.unstable_rowHasAutoHeight(row.id);\n    }\n\n    if (!hasRowWithAutoHeight) {\n      firstColumnIndex = binarySearch(left, columnPositions);\n      lastColumnIndex = binarySearch(left + containerWidth, columnPositions);\n    }\n\n    return {\n      firstRowIndex,\n      lastRowIndex,\n      firstColumnIndex,\n      lastColumnIndex\n    };\n  }, [disableVirtualization, getNearestIndexToRender, rowsMeta.positions.length, rootProps.autoHeight, rootProps.rowBuffer, currentPage.rows, columnPositions, visibleColumns.length, apiRef, containerWidth]);\n  React.useEffect(() => {\n    if (disableVirtualization) {\n      renderZoneRef.current.style.transform = `translate3d(0px, 0px, 0px)`;\n    } else {\n      // TODO a scroll reset should not be necessary\n      rootRef.current.scrollLeft = 0;\n      rootRef.current.scrollTop = 0;\n    }\n  }, [disableVirtualization]);\n  React.useEffect(() => {\n    setContainerWidth(rootRef.current.clientWidth);\n  }, [rowsMeta.currentPageTotalHeight]);\n  const handleResize = React.useCallback(params => {\n    setContainerWidth(params.width);\n  }, []);\n  useGridApiEventHandler(apiRef, 'resize', handleResize);\n  const updateRenderZonePosition = React.useCallback(nextRenderContext => {\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstRowIndex,\n      lastIndex: nextRenderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rootProps.rowBuffer\n    });\n    const [initialFirstColumnToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstColumnIndex,\n      lastIndex: nextRenderContext.lastColumnIndex,\n      minFirstIndex: renderZoneMinColumnIndex,\n      maxLastIndex: renderZoneMaxColumnIndex,\n      buffer: rootProps.columnBuffer\n    });\n    const firstColumnToRender = getFirstNonSpannedColumnToRender({\n      firstColumnToRender: initialFirstColumnToRender,\n      apiRef,\n      firstRowToRender,\n      lastRowToRender,\n      visibleRows: currentPage.rows\n    });\n    const top = gridRowsMetaSelector(apiRef.current.state).positions[firstRowToRender];\n    const left = gridColumnPositionsSelector(apiRef)[firstColumnToRender]; // Call directly the selector because it might be outdated when this method is called\n\n    renderZoneRef.current.style.transform = `translate3d(${left}px, ${top}px, 0px)`;\n\n    if (typeof onRenderZonePositioning === 'function') {\n      onRenderZonePositioning({\n        top,\n        left\n      });\n    }\n  }, [apiRef, currentPage.rows, onRenderZonePositioning, renderZoneMinColumnIndex, renderZoneMaxColumnIndex, rootProps.columnBuffer, rootProps.rowBuffer]);\n  React.useLayoutEffect(() => {\n    if (renderContext) {\n      updateRenderZonePosition(renderContext);\n    }\n  }, [renderContext, updateRenderZonePosition]);\n  const updateRenderContext = React.useCallback(nextRenderContext => {\n    setRenderContext(nextRenderContext);\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstRowIndex,\n      lastIndex: nextRenderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rootProps.rowBuffer\n    });\n    apiRef.current.publishEvent('renderedRowsIntervalChange', {\n      firstRowToRender,\n      lastRowToRender\n    });\n    prevRenderContext.current = nextRenderContext;\n  }, [apiRef, setRenderContext, prevRenderContext, currentPage.rows.length, rootProps.rowBuffer]);\n  React.useEffect(() => {\n    if (containerWidth == null) {\n      return;\n    }\n\n    const initialRenderContext = computeRenderContext();\n    updateRenderContext(initialRenderContext);\n    const {\n      top,\n      left\n    } = scrollPosition.current;\n    const params = {\n      top,\n      left,\n      renderContext: initialRenderContext\n    };\n    apiRef.current.publishEvent('rowsScroll', params);\n  }, [apiRef, computeRenderContext, containerWidth, updateRenderContext]);\n\n  const handleScroll = event => {\n    const {\n      scrollTop,\n      scrollLeft\n    } = event.currentTarget;\n    scrollPosition.current.top = scrollTop;\n    scrollPosition.current.left = scrollLeft; // On iOS and macOS, negative offsets are possible when swiping past the start\n\n    if (scrollLeft < 0 || scrollTop < 0 || !prevRenderContext.current) {\n      return;\n    } // When virtualization is disabled, the context never changes during scroll\n\n\n    const nextRenderContext = disableVirtualization ? prevRenderContext.current : computeRenderContext();\n    const topRowsScrolledSincePreviousRender = Math.abs(nextRenderContext.firstRowIndex - prevRenderContext.current.firstRowIndex);\n    const bottomRowsScrolledSincePreviousRender = Math.abs(nextRenderContext.lastRowIndex - prevRenderContext.current.lastRowIndex);\n    const topColumnsScrolledSincePreviousRender = Math.abs(nextRenderContext.firstColumnIndex - prevRenderContext.current.firstColumnIndex);\n    const bottomColumnsScrolledSincePreviousRender = Math.abs(nextRenderContext.lastColumnIndex - prevRenderContext.current.lastColumnIndex);\n    const shouldSetState = topRowsScrolledSincePreviousRender >= rootProps.rowThreshold || bottomRowsScrolledSincePreviousRender >= rootProps.rowThreshold || topColumnsScrolledSincePreviousRender >= rootProps.columnThreshold || bottomColumnsScrolledSincePreviousRender >= rootProps.columnThreshold || prevTotalWidth.current !== columnsTotalWidth; // TODO v6: rename event to a wider name, it's not only fired for row scrolling\n\n    apiRef.current.publishEvent('rowsScroll', {\n      top: scrollTop,\n      left: scrollLeft,\n      renderContext: shouldSetState ? nextRenderContext : prevRenderContext.current\n    }, event);\n\n    if (shouldSetState) {\n      // Prevents batching render context changes\n      ReactDOM.flushSync(() => {\n        updateRenderContext(nextRenderContext);\n      });\n      prevTotalWidth.current = columnsTotalWidth;\n    }\n  };\n\n  const handleWheel = event => {\n    apiRef.current.publishEvent('virtualScrollerWheel', {}, event);\n  };\n\n  const handleTouchMove = event => {\n    apiRef.current.publishEvent('virtualScrollerTouchMove', {}, event);\n  };\n\n  const getRows = (params = {\n    renderContext\n  }) => {\n    const {\n      renderContext: nextRenderContext,\n      minFirstColumn = renderZoneMinColumnIndex,\n      maxLastColumn = renderZoneMaxColumnIndex,\n      availableSpace = containerWidth,\n      rowIndexOffset = 0,\n      position = 'center'\n    } = params;\n\n    if (!nextRenderContext || availableSpace == null) {\n      return null;\n    }\n\n    const rowBuffer = !disableVirtualization ? rootProps.rowBuffer : 0;\n    const columnBuffer = !disableVirtualization ? rootProps.columnBuffer : 0;\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstRowIndex,\n      lastIndex: nextRenderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rowBuffer\n    });\n    const renderedRows = [];\n\n    if (params.rows) {\n      params.rows.forEach(row => {\n        renderedRows.push(row);\n        apiRef.current.unstable_calculateColSpan({\n          rowId: row.id,\n          minFirstColumn,\n          maxLastColumn,\n          columns: visibleColumns\n        });\n      });\n    } else {\n      if (!currentPage.range) {\n        return null;\n      }\n\n      for (let i = firstRowToRender; i < lastRowToRender; i += 1) {\n        const row = currentPage.rows[i];\n        renderedRows.push(row);\n        apiRef.current.unstable_calculateColSpan({\n          rowId: row.id,\n          minFirstColumn,\n          maxLastColumn,\n          columns: visibleColumns\n        });\n      }\n    }\n\n    const [initialFirstColumnToRender, lastColumnToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstColumnIndex,\n      lastIndex: nextRenderContext.lastColumnIndex,\n      minFirstIndex: minFirstColumn,\n      maxLastIndex: maxLastColumn,\n      buffer: columnBuffer\n    });\n    const firstColumnToRender = getFirstNonSpannedColumnToRender({\n      firstColumnToRender: initialFirstColumnToRender,\n      apiRef,\n      firstRowToRender,\n      lastRowToRender,\n      visibleRows: currentPage.rows\n    });\n    const renderedColumns = visibleColumns.slice(firstColumnToRender, lastColumnToRender);\n    const rows = [];\n\n    for (let i = 0; i < renderedRows.length; i += 1) {\n      var _currentPage$range5, _rootProps$components;\n\n      const {\n        id,\n        model\n      } = renderedRows[i];\n      const lastVisibleRowIndex = firstRowToRender + i === currentPage.rows.length - 1;\n      const baseRowHeight = !apiRef.current.unstable_rowHasAutoHeight(id) ? apiRef.current.unstable_getRowHeight(id) : 'auto';\n      let isSelected;\n\n      if (selectedRowsLookup[id] == null) {\n        isSelected = false;\n      } else {\n        isSelected = apiRef.current.isRowSelectable(id);\n      }\n\n      rows.push( /*#__PURE__*/_jsx(rootProps.components.Row, _extends({\n        row: model,\n        rowId: id,\n        rowHeight: baseRowHeight,\n        cellFocus: cellFocus // TODO move to inside the row\n        ,\n        cellTabIndex: cellTabIndex // TODO move to inside the row\n        ,\n        editRowsState: editRowsState // TODO move to inside the row\n        ,\n        renderedColumns: renderedColumns,\n        visibleColumns: visibleColumns,\n        firstColumnToRender: firstColumnToRender,\n        lastColumnToRender: lastColumnToRender,\n        selected: isSelected,\n        index: rowIndexOffset + ((currentPage == null ? void 0 : (_currentPage$range5 = currentPage.range) == null ? void 0 : _currentPage$range5.firstRowIndex) || 0) + firstRowToRender + i,\n        containerWidth: availableSpace,\n        isLastVisible: lastVisibleRowIndex,\n        position: position\n      }, typeof getRowProps === 'function' ? getRowProps(id, model) : {}, (_rootProps$components = rootProps.componentsProps) == null ? void 0 : _rootProps$components.row), id));\n    }\n\n    return rows;\n  };\n\n  const needsHorizontalScrollbar = containerWidth && columnsTotalWidth > containerWidth;\n  const contentSize = React.useMemo(() => {\n    // In cases where the columns exceed the available width,\n    // the horizontal scrollbar should be shown even when there're no rows.\n    // Keeping 1px as minimum height ensures that the scrollbar will visible if necessary.\n    const height = Math.max(rowsMeta.currentPageTotalHeight, 1);\n    let shouldExtendContent = false;\n\n    if (rootRef != null && rootRef.current && height <= (rootRef == null ? void 0 : rootRef.current.clientHeight)) {\n      shouldExtendContent = true;\n    }\n\n    const size = {\n      width: needsHorizontalScrollbar ? columnsTotalWidth : 'auto',\n      height,\n      minHeight: shouldExtendContent ? '100%' : 'auto'\n    };\n\n    if (rootProps.autoHeight && currentPage.rows.length === 0) {\n      size.height = 2 * rowHeight; // Give room to show the overlay when there's no row.\n    }\n\n    return size;\n  }, [rootRef, columnsTotalWidth, rowsMeta.currentPageTotalHeight, currentPage.rows.length, needsHorizontalScrollbar, rootProps.autoHeight, rowHeight]);\n  React.useEffect(() => {\n    apiRef.current.publishEvent('virtualScrollerContentSizeChange');\n  }, [apiRef, contentSize]);\n\n  if (rootProps.autoHeight && currentPage.rows.length === 0) {\n    contentSize.height = 2 * rowHeight; // Give room to show the overlay when there no rows.\n  }\n\n  const rootStyle = {};\n\n  if (!needsHorizontalScrollbar) {\n    rootStyle.overflowX = 'hidden';\n  }\n\n  if (rootProps.autoHeight) {\n    rootStyle.overflowY = 'hidden';\n  }\n\n  const getRenderContext = React.useCallback(() => {\n    return prevRenderContext.current;\n  }, []);\n  apiRef.current.unstable_getRenderContext = getRenderContext;\n  return {\n    renderContext,\n    updateRenderZonePosition,\n    getRows,\n    getRootProps: (_ref = {}) => {\n      let {\n        style = {}\n      } = _ref,\n          other = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n      return _extends({\n        ref: handleRef,\n        onScroll: handleScroll,\n        onWheel: handleWheel,\n        onTouchMove: handleTouchMove,\n        style: _extends({}, style, rootStyle)\n      }, other);\n    },\n    getContentProps: ({\n      style = {}\n    } = {}) => ({\n      style: _extends({}, style, contentSize)\n    }),\n    getRenderZoneProps: () => ({\n      ref: renderZoneRef\n    })\n  };\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}